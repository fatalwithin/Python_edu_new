# Структуры данных

### Списки

Под *структурами данных* понимается способ хранения и организации данных для их дальнейшего эффективного использования.

> Список (list) — это структура данных, которая хранит изменяемую последовательность произвольных элементов. Элементами списка могут быть любые объекты, например: числа, строки, словари, объекты классов, сами классы и другие списки.

Как только список создан, над ним можно производить следующие операции:

```python
>>> list('новый список') # создание списка из строки
['н', 'о', 'в', 'ы', 'й', ' ', 'с', 'п', 'и', 'с', 'о', 'к']
>>> s = [] # создание пустого списка
>>> l = [1,23, [], {}, "111"]
# список, заполненный различным содержанием
>>> s
[]
>>> l
[1, 23, [], {}, '111']
>>> s.append(1) # добавление в конец списка
>>> s
[1]
>>> l[1] # взять элемент из списка L по индексу 1
23
>>> len(l) # длина списка l
5
>>> l[4] = "omg"
>>> l
[1, 23, [], {}, 'omg']
>>> l.pop(2) # удалить из списка элемент по индексу и вернуть его
[]
>>> l
[1, 23, {}, 'omg']
```



**Полезная ссылка**

Более подробно об операциях над списками можно [узнать тут.](https://docs.python.org/3/tutorial/datastructures.html)



*List Comprehensions* — это синтаксический сахар Python, который позволяет удобно генерировать новые списки:

```python
squares = [x ** 2 for x in range(10)]
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

Функция **range(start, stop, step)** — это стандартная функция Python, которая позволяет генерировать последовательность чисел. **Range** принимает три параметра: **start**, **stop**, **step**, где **start** — начало последовательности, **stop** — конец последовательности и **step** — шаг. По умолчания **start = 0**, **step = 1**.

Как и в обычных циклах **for**, внутри *list comprehensions* можно использовать условия с применением условных выражений **if - elif - else**:

```bash
>>> odds = [x for x in range(10) if x % 2 != 0]
# [1, 3, 5, 7, 9]
```

Или так:

```bash
>>> [x ** 2 if x % 2 == 0 else x ** 3 for x in range(10)]
# [0, 1, 4, 27, 16, 125, 36, 343, 64, 729]
```

Также можно использовать несколько циклов **for** или выражений **if-elif-else**. Это бывает удобно, когда нужно произвести операции над несколькими списками:

```python
second = [(x, y) for x in range(1, 5) for y in range(5, 1, -1) if x != y]
```

### Как устроены списки внутри Python

Внутри СPython cписки реализованы в виде динамических массивов, поэтому разработчику можно не задумываться о выделении дополнительного места при добавлении и удалении элементов.

CPython — наиболее распространённая, де-факто эталонная реализация языка программирования Python. CPython является интерпретатором байт-кода, написан на C. Кроме CPython, существуют другие реализации Python: [Jython](https://ru.wikipedia.org/wiki/Jython), [IronPython](https://ru.wikipedia.org/wiki/IronPython), [PyPy](https://ru.wikipedia.org/wiki/PyPy) и [Stackless Python](https://ru.wikipedia.org/wiki/Stackless_Python).

Объект списка представлен в виде следующей C-структуры:

```python
typedef struct {
    PyObject_VAR_HEAD
    PyObject **ob_item;
    Py_ssize_t allocated;
} PyListObject;
```

где:

**PyObject_VAR_HEAD** — C-макрос, который используется внутри CPython для структур с переменным количеством элементов;

**PyObject \**ob_item** — список указателей на элементы списка для быстрого доступа по индексу;

**Py_ssize_t allocated** — константа, которая указывает на границу аллоцированной памяти. При добавлении нового элемента и превышении объема памяти будет произведен процесс выделения новой памяти для новых элементов.

### Сложность основных операций в нотации big (O)

Big (O) — математическая нотация, которая описывает ограничивающее поведение функции, аргумент которой стремится к определенному значению или бесконечности. Иными словами, данная нотация описывает сложность кода с использованием алгебраических терминов.

Основные затраты по времени / памяти приходятся на добавление элементов (append), т.к. происходит выделение дополнительного места в памяти, а также при удалении / вставке элементов в начало.

Далее **n** — количество элементов в списке; **k** — значение параметра, либо количество элементов в параметре.

| **Операция**           | **Средняя сложность** |
| ---------------------- | --------------------- |
| Обращение по индексу   | O(1)                  |
| Присвоение             | O(1)                  |
| len                    | O(1)                  |
| append                 | O(1)                  |
| pop                    | O(1)                  |
| clear                  | O(1)                  |
| slice                  | O(k)                  |
| extend                 | O(k)                  |
| Создание               | O(k)                  |
| Проверки ==, !=        | O(n)                  |
| insert                 | O(n)                  |
| del                    | O(n)                  |
| remove                 | O(n)                  |
| Проверка на входимость | O(n)                  |
| copy                   | O(n)                  |
| min, max               | O(n)                  |
| reverse                | O(n)                  |
| Проход                 | O(n)                  |
| Присвоение среза       | O(k+n)                |
| sort                   | O(n log n)            |
| Умножение              | O(k×n)                |

### Что означают данные в таблице? 

Интерпретировать данные можно следующим образом: сложность **O(1)** означает, что на данную операцию будет затрачено константное время. Для операций типа **O(n)** или **O(k)** время выполнения будет расти линейно, в зависимости от числа элементов или значения параметра функции соответственно. Чем сложнее операция, тем быстрее будет возрастать время на ее выполнение.

![img](https://cs.sberbank-school.ru/image/1000/auto/upsize/18b1d012-5bc4-11eb-a480-0242ac140004)



### Применение на практике

На практике списки применяются, когда необходимо работать с набором значений, связанных логически. Например, объекты на парковке — это могут быть автомобили, мотоциклы и т. д. Будет удобно объединить эти элементы в список и выполнять над ними нужные действия, допустим, проверять, занято ли парковочное место или нет. Естественно предположить, что количество мест на парковке может изменяться со временем, она может быть пуста утром и заполнена вечером. Такая структура данных, как список, легко поможет реализовать добавление / удаление / доступ по индексу для описания объектов на парковке.



## Кортежи, NamedTuple

> Кортеж (tuple), как и список, — это структура данных, которая хранит неизменяемую последовательность произвольных элементов. 

В отличие от списка, элементы кортежа должны быть определены во время его создания, следовательно, кортежи не поддерживают динамическое добавление и удаление элементов:

```python
>>> a = [1,2,3]
>>> b = (1,2,3)
>>> a
[1, 2, 3]
>>> b
(1, 2, 3)
>>> a[0]
1
>>> b[0]
1
>>> a[0]=5
>>> b[0]=b
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> a
[5, 2, 3]
>>> del a[0]
>>> a
[2, 3]
>>> del b[0]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object doesn't support item deletion
```

#### Как кортежи устроены внутри Python

Внутри CPython кортежи организованы похожим образом, как и списки, за исключением нескольких деталей.

```python
typedef struct {
    PyObject_VAR_HEAD
    PyObject *ob_item[1];
} PyTupleObject;
```

где:

**PyObject_VAR_HEAD** — C-макрос, который используется внутри CPython для структур с переменным количеством элементов,

**PyTupleObject \*ob_item[1]** — указатели на элементы кортежа.

#### Сложность основных операций в нотации big (O)

Схожа со списками, за исключением операций, которые недопустимы для кортежей.



### Применение на практике

Кортежи похожи на списки, но их значения не могут быть изменены. Из-за этого, когда вы используете кортежи в своем коде, вы как будто сообщаете другим программистам, что не собираетесь вносить изменения в эту последовательность значений. 

Очень часто во время разработки ПО полезно бывает написать часть кода, используя списки. Поняв, какие из них реально меняются со временем, а какие остаются неизменными, провести небольшой рефакторинг и заменить необходимые **lists** на **tuple**, таким образом произвести оптимизацию программы.



### Именованные кортежи (namedtuple)

*Именованные кортежи* — это подкласс обычных кортежей, их удобство заключается в двух вещах:

1. они неизменяемые, так же как и обычные кортежи и имеют все их свойства;
2. каждый элемент кортежа доступен по уникальному строковому идентификатору. 

```python
>>> from collections import namedtuple
>>> Car = namedtuple('Car' , 'color speed')
>>> my_car = Car('red', 200)
>>> my_car.color
'red'
>>> my_car.speed
200
```

**namedtuple** содержится в модуле **collections**, который, помимо **deque**, несет в себе другие «продвинутые» структуры данных, такие как: **ChainMap**, **defaultdict**, **deque**, **OrderedDict**.

Несмотря на доступ к значениям сохраненным в именованном кортеже через их идентификатор, вы всё ещё можете обращаться к ним через их индекс. Это свойство именованных кортежей может быть использовано для их распаковки в обычный кортеж:

```python
>>> my_car[0]
'red'
>>> tuple(my_car)
('red', 200)
```

Объекты именованных кортежей внутренне реализуются в Python как обычные классы. Если смотреть с точки зрения эффективного использования памяти, то они лучше, чем обычные классы, при этом сохраняют удобство кортежей.



### Применение на практике

Именованные кортежи удобно использовать, когда в собственном классе нужно выделить значения, которые логически объединены, но не тянут на создание отдельного класса, т.к. не переиспользуются вне этого класса.



## Deque

> Deque — это структура данных, которая реализует двустороннюю очередь.

Она поддерживает добавление и удаление элементов с любого конца за время **O(1)**:

```python
>>> import collections
>>> de = collections.deque([1,2,3])
>>> de
deque([1, 2, 3])
>>> de.append(4)
>>> de
deque([1, 2, 3, 4])
>>> de.appendleft(6)
>>> de
deque([6, 1, 2, 3, 4])
>>> de.pop()
4
>>> de
deque([6, 1, 2, 3])
>>> de.popleft()
6
>>> de
deque([1, 2, 3])
```

Объекты **deque** в Python реализованы в виде двусвязных списков, что дает им отличную производительность для постановки в очередь и удаления из очереди, но низкую производительность **O(n)** для произвольного доступа к элементам в середине очереди.

#### Как очереди устроены внутри Python

В реализации CPython структура объекта **deque** выглядит следующим образом:

```python
typedef struct {
    PyObject_VAR_HEAD
    block *leftblock;
    block *rightblock;
    Py_ssize_t leftindex;
    Py_ssize_t rightindex;
    size_t state;
    PyObject *weakreflist
} dequeobject;
```

где:

**PyObject_VAR_HEAD** — C-макрос, который используется внутри CPython для структур с переменным количеством элементов;

**block \*leftblock** — указатель на левый блок, для добавления элементов слева;

**block \*rightblock** — аналогично, что и **leftblock**, но для добавления элементов справа;

**Py_ssize_t leftindex** — индекс левого края объекта **deque**;

**Py_ssize_t rightindex** — индекс правого края объекта **deque**;

**size_t state** — переменная для отслеживания изменения индексов;

**PyObject \*weakreflist** — список ссылок для сборщика мусора.



### Применение на практике

Поскольку **deque** одинаково хорошо поддерживает добавление и удаление элементов с обоих концов, на практике их удобно использовать для реализации *очередей* (FIFO — первый вошел, первый вышел) и *стеков* (FILO — первый вошел, последний вышел). 



## Множества, FrozenSet

> Множество (Set) — это структура данных, которая хранит неупорядоченные уникальные хешируемые элементы. 

```python
>>> s = set() # создание пустого множества
>>> s
set()
>>> s = set((1,2,3,4,5)) # cоздание множества из кортежа
>>> s = set([1,2,3,4,5]) # создание множества из списка
>>> s = {1, 2, 3, 4, 5} # еще вариант создания множества
>>> s
{1, 2, 3, 4, 5}
>>> s = {1, 2, 3, 4, 5, "test", ()}
>>> s
{1, 2, 3, 4, 5, (), 'test'}
>>> s.add("new test") # добавление нового элемента
>>> s
{1, 2, 3, 4, 5, 'new test', (), 'test'}
>>> s.add(3) 
>>> s
{1, 2, 3, 4, 5, 'new test', (), 'test'}
# после добавления 3 все осталось без изменений
>>> s.add([]) # нельзя добавить список, тк он нехешируемый
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> s.discard(3) # удаление элемента из множества
>>> s
{1, 2, 4, 5, 'new test', (), 'test'}
>>> first_part = set((1,2,3,4,5))
>>> second_part = set((6,7,8,9,10))
>>> first_part.union(second_part) # объединение двух множеств
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
>>> first_part.intersection(second_part) 
# пересечение двух множеств
set()
```



### Полезная ссылка

Более подробно об операциях над множествами можно [узнать тут](https://docs.python.org/2/library/sets.html).



*Set Comprehensions* — как и при генерации списков, Python поддерживает синтаксический сахар для генерации множеств: 

```python
>>> {s for s in [1, 2, 1, 0]}
set([0, 1, 2])
>>> {s**2 for s in [1, 2, 1, 0]}
set([0, 1, 4])
>>> {s**2 for s in range(10)}
set([0, 1, 4, 9, 16, 25, 36, 49, 64, 81])
```

Также можно использовать выражение **if-elif-else**:

```python
>>> {s for s in [1, 2, 3] if s % 2}
set([1, 3])
```

Использовать несколько циклов **for**:

```python
>>> {(m, n) for n in range(2) for m in range(3, 5)}
set([(3, 0), (3, 1), (4, 0), (4, 1)])
```

#### Сложность основных операций в нотации big (O)

Таблица времени выполнения операций над множествами в нотации Big O выглядит следующим образом:

| **Операция**           | **Средняя сложность**  |
| ---------------------- | ---------------------- |
| len                    | O(1)                   |
| add                    | O(1)                   |
| Проверка на входимость | O(1)                   |
| .remove                | O(1)                   |
| .discard               | O(1)                   |
| .pop                   | O(1)                   |
| .clear                 | O(1)                   |
| Создание               | O(len(t))              |
| Проверки ==, !=        | O(len(s))              |
| s.issubset(t)          | O(len(s))              |
| t.issuperset(s)        | O(len(t))              |
| .union                 | O(len(s)+len(t))       |
| .intersection          | O(min(len(s), len(t))) |
| .difference            | O(len(s))              |
| .symmetric_difference  | O(len(s))              |
| Проход                 | O(n)                   |
| .copy                  | O(n)                   |

#### Как множества устроены внутри Python

Внутри множества представляют таблицу, в ячейки которой добавляют новые элементы. В СPython множества представляют следующую структуру:

```python
typedef struct{
    PyObject_HEAD
    Py_ssize_t fill;
    Py_ssize_t used;
    Py_ssize_t mask;
    setentry *table;
    Py_hash_t hash;
    Py_ssize_t finger;
    setentry smalltable[PySet_MINSIZE];
    PyObject *weakreflist;
} PySetObject;
```

где:

**PyObject_HEAD** — С-макрос, используется при объявлении новых типов, представляющих объекты без переменной длины;

**Py_ssize_t fill** — количество активных и фиктивных записей;

**Py_ssize_t used** — количество активных записей;

**setentry \*table** — указатель на таблицу, где хранятся данные;

**Py_hash_t hash** — хеш, заполняется только в случае **frozen set**;

**Py_ssize_t finger** — специальная переменная для определения элемента, который нужно выкинуть из коллекции при операции **pop()**;

**PyObject \*weakreflist** — список ссылок для сборщика мусора.



### Применение на практике

На практике множества используются для быстрой проверки значения на принадлежность нового элемента к некоторому набору данных, для вставки или удаления новых значений из набора и для вычисления объединения или пересечения двух наборов.



### Frozen Set

*Неизменяемая версия множеств* — уникальный и хешируемый набор элементов в структуре, так же, как и в обычном множестве. Отличается отсутствием возможности добавить или удалить новый элемент.

```python
>>> a = frozenset((1,2,3))
>>> a
frozenset({1, 2, 3})
>>> a.add(2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'frozenset' object has no attribute 'add'
```



## Словари, OrderedDict, DefaultDict

> Словарь (Dict) — это структура данных, которая хранит элементы по принципу ключ-значение.

Это позволяет эффективно искать, вставлять, изменять и удалять любой объект связанный с ключом. Словарь в Python является реализацией абстрактной структуры данных — *хеш-таблица*. 

Все ключи в словарях должны быть хешируемыми. *Хеш-объект* имеет значение, которое никогда не изменяется в течение жизни объекта (свойство **__hash__**), также это значение можно сравнить с другими похожими объектами (свойство **__eq__**).

Кстати говоря, если мы сравниваем два объекта в Python, можно говорить об их равенстве только в том случае, если их хеши и значения одинаковые.

Из свойства хешируемости следует, что в Python ключами словаря могут быть объекты, неизменяемые со временем (Immutable), — это строки, числа, пользовательские объекты, у которых реализованы свойства (**__hash__**, **__eq__**). **Tuple**, **frozen set** могут быть ключами словаря — если в их составе нет изменяемых элементов, например — списки, множества.

```python
>>> d = {} # создание словаря
>>> d = {"a":1, "abc":2}
>>> d
{'a': 1, 'abc': 2}
>>> d = dict([(1,2), (3,4)]) # еще одна возможность создать словарь
>>> d
{1: 2, 3: 4}
>>> d.clear() # очистка словаря
>>> d
{}
>>> d = dict([(1,2), (3,4)])
>>> d
{1: 2, 3: 4}
>>> d[1] # взять элемент словаря по ключу
2
>>> d[5] # ошибка, если такого ключа нет
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 5
>>> d[7] = 15 # добавление нового ключа
>>> d
{1: 2, 3: 4, 7: 15}
>>> d[(1,2)] = 144 # добавление нового ключа, в качестве которого используется кортеж
>>> d
{1: 2, 3: 4, 7: 15, (1, 2): 144}
>>> d[[1]] = 5 # ошибка, т.к. список не может быть ключом словаря
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> d.items() # показать пары ключ / значение
dict_items([(1, 2), (3, 4), (7, 15), ((1, 2), 144)])
>>> d.keys() # только ключ
dict_keys([1, 3, 7, (1, 2)])
>>> d.values() # только значения
dict_values([2, 4, 15, 144])
```



### Полезная ссылка

Более подробное описание операций над словарями можно посмотреть [тут](https://docs.python.org/3/tutorial/datastructures.html).



*Dict Comprehensions* — аналогично с **list**, **set** существует семантический сахар и для создания словарей.

```python
d = {a: a ** 2 for a in range(7)}
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
```

Для хеш-таблиц свойственно появление *коллизий* — это когда два разных объекта имеют одинаковый хеш. Существуют разные способы разрешения коллизий. Внутри CPython реализован метод открытой адресации.

#### Как словари устроены внутри Python

Внутри CPython словарь, как и множество, хранится в виде таблицы, а сама структура ячейки словаря описывается в CPython следующей структурой:

```python
typedef struct {
    Py_hash_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictEntry;
```

где:

**me_hash** — хеш хранимого объекта;

**me_key** — ключ хранимого объекта;

**me_value** — значение хранимого объекта.

#### Сложность основных операций в нотации big (O)

| **Операция**         | **Средняя сложность** |
| -------------------- | --------------------- |
| Обращение по индексу | O(1)                  |
| Присвоение           | O(1)                  |
| len                  | O(1)                  |
| del                  | O(1)                  |
| .setdefault          | O(1)                  |
| .pop                 | O(1)                  |
| .popitem             | O(1)                  |
| .clear               | O(1)                  |
| Представление        | O(1)                  |
| Создание             | O(k)                  |
| Проход               | O(n)                  |
| .copy                | O(n)                  |



### Применение на практике

Так как сам словарь устроен как ключ-значение, то применение его ограничивается областью, когда нужно логически связать одно значение с другим. Это может быть и хранение доменных имен, и связанных с ними ip-адресов, и хранение настроек своего приложения, где ключами выступают подсистемы проекта, а значениями также словари, хранящие первоначальную конфигурацию для запуска.



### OrderedDict

Подкласс словаря, в котором хранится порядок добавления ключей в словарь.

Удобно использовать, когда нужно не только получать значения по ключу, но и время от времени итерироваться по структуре, зная, что вначале идут более ранние значения, а в конце более поздние:

```python
>>> import collections
>>> d = collections.OrderedDict(one=1, two=2, three=3)
>>> d
OrderedDict([('one', 1), ('two', 2), ('three', 3)])
>>> d['four'] = 4
>>> d
OrderedDict([('one', 1), ('two', 2), ('three', 3), ('four', 4)])
>>> d.keys()
odict_keys(['one', 'two', 'three', 'four'])
```

Начиная с python 3.6+, обычный словарь так же хранит данный порядок и, по сути, **OrderedDict** можно не использовать.

### DefaultDict

Подкласс словаря, особенностью которого является возможность задать значение по умолчанию, которое будет возвращено в случае обращения к словарю по ключу, который отсутствует. 

```python
>>> from collections import defaultdict
>>> dd = defaultdict(list)
# Accessing a missing key creates it and initializes it
# using the default factory, i.e. list() in this example:
>>> dd['dogs'].append('Rufus')
>>> dd['dogs'].append('Kathrin')
>>> dd['dogs'].append('Mr Sniffles')
>>> dd['dogs']
['Rufus', 'Kathrin', 'Mr Sniffles']
```



### Задание 2

В этом модуле мы коснулись внутреннего устройства структур в Python, пришло время посмотреть, сколько каждая из них занимает места в памяти.

Вам понадобится модуль **sys** и методы **sys.getsizeof()** и **__sizeof__()**.

В официальной документации сказано:

«**sys.getsizeof(объект[, значение по умолчанию])** — возвращает размер объекта в байтах. Если указано значение по умолчанию, то оно вернется, если объект не предоставляет способа получить размер. В противном случае возникнет исключение **TypeError.Getsizeof()** вызывает метод объекта **__sizeof__** и добавляет размер дополнительной информации, которая хранится для сборщика мусора, если он используется».

Вам нужно создать объекты рассмотренных структур данных и, используя данные функции, посмотреть, сколько памяти необходимо той или иной структуре.

```python
import sys

def simple_get_true_size(obj, mem=None):
  size = sys.getsizeof(obj) # size of primary structure
  if mem is None:
    mem = set() # base condition of recursive function
    
  obj_id = id(obj)
  if obj_id in mem:
    return 0
  
  mem.add(obj_id)
  
  if isinstance(obj, dict): # add dictionary size
    size += sum([simple_get_true_size(key, mem) for key in obj.keys()])
    size += sum([simple_get_true_size(value, mem) for value in obj.values()])
    
  elif hasattr(obj, '__dict__'): # add dictionary size for custom classes
    size += simple_get_true_size(obj.__dict__, mem)
  
  elif hasattr(obj, '__iter__'): # add size for iterable objects
    size += sum([simple_get_true_size(i, mem) for i in obj])
    
  return size

```



 

# Функции

## Основы функций

> Функция — это блок организованного, многократно используемого кода, который используется для выполнения одного связанного действия. Функции обеспечивают модульность и высокую степень повторного использования кода.

Существуют встроенные функции Python — **print()**, **len()**, **str()** и т.д., и пользовательские.

#### Как создать собственную функцию?

Создать собственную функцию в Python очень просто:

- Функция начинается с ключевого слова **def**, имени функции и круглых скобок **().**
- Входные параметры определяются внутри круглых скобок.
- Дальше необязательно, но может следовать **docstring** — описание функции.
- Каждая функция после скобок начинается с двоеточия (**:**) и имеет отступы.
- Чтобы вернуть результат работы функции нужно использовать ключевое слово **return**, но если оно не указано, то это равноценно **return None.**

Пример, который иллюстрирует вышеописанные свойства:

```python
def function_name(param1, param2, param3):
    "function_docstring"
    some work
    return [expression]
```

Как только функция определена, можно вызвать ее в любом месте в программе следующим образом:

```python
result = function_name("str1", 2, [1,2,3])
print(result)
```

Мы передаем значения в функцию и ожидаем результат, который потом выводим, используя функцию **print()**.

#### Как передаются параметры в функцию?

Во многих языках программирования существует передача аргументов в функцию по ссылке или по значению. В Python правильно будет сказать, что идет передача по ссылке на объект (PASS-BY-OBJECT-REFERENCE). 

Тут важно понимать, что переменная — это указатель на какой-либо объект, но переменная — это не сам объект. 

```python
def append(my_list): 
    my_list.append(1) 
x = [0] 
append(x) 
print(x)
```

Тут мы создаем список **x = [0]**, передаем это в функцию **append()**, переменная **my_list** так же ссылается на объект списка, поэтому при вызове **append()** мы изменим исходных список, на который ссылается **x**:

print x -> [0,1]

Рассмотрим другой пример:

```python
def append(my_list): 
    my_list = [0, 1] 
x = [0] 
append(x) 
print(x)
```

Результатом работы будет **[0]**, т.к. внутри функции создается новый список и в тот момент времени **my_list** указывает на **[0,1]**, а **x** все равно указывает на **[0]**.

Собственно говоря, поведение из первого примера свойственно для всех изменяемых объектов — **list**, **dict**, **set**.

#### Какие различают аргументы в функциях?

В Python существует гибкая настройка аргументов функции, различают следующие:

- обязательные аргументы;
- ключевые аргументы;
- аргументы по умолчанию;
- изменяемое число аргументов.

*Обязательные аргументы* — это аргументы, которые были переданы в функцию в правильном позиционном порядке. Количество передаваемых аргументов должно соответствовать количеству описанных аргументов:

```python
def print_func(str_to_print):
    print(str_to_print)
print_func()
TypeError: print_func() takes exactly 1 argument (0 given)
```

Получаем ошибку, т.к. вызвали функцию с неправильным числом аргументов.

```python
def print_func(str_to_print):
    print(str_to_print)
print_func("test") # так отработает корректно
```

*Ключевые аргументы* — когда при вызове функции, разработчик явно указывает аргументы функции и переменные извне, которые им соответствуют. Таким образом жесткий порядок не нужен:

```python
def print_func(str_to_print, int_to_print):
    print(str_to_print)
    print(int_to_print)
print_func(int_to_print=50, str_to_print="test")
```

*Аргументы по умолчанию* — это аргумент, который принимает значение по умолчанию, если не указано значение во время вызова функции. 

```python
def print_func(str_to_print, int_to_print=50):
    print(str_to_print)
    print(int_to_print)
print_func(name="test")
```



## *args и **kwargs

> *Изменяемое число аргументов — \*args, **kwargs.*

*args — для неименованных аргументов.

*\*kwargs — для именованных аргументов.

Такой подход применяется, когда количество аргументов в функции заранее неизвестно.

\*args — в этом случае переменные передаются как кортеж и доступны под тем именем, что указано при объявлении аргумента.

```python
def summator(*nums):
    sum = 0
    for n in nums:
        sum += n
    print(sum)
summator(3, 5)
summator(4, 5, 6, 7)
summator(1, 2, 3, 5, 6)
```

\**kwargs — в этом случае переменные передаются как словарь и доступны под тем именем, что указано при объявлении аргумента.

```python
def inside_kwargs(**kwargs):
    print("kwargs type is", type(kwargs))
    for key, value in kwargs.items():
        print(key, value)
inside_kwargs(Company="Sberbank", info="python_course", location="online")
```

*args, **kwargs — устоявшиеся названия переменных для передачи неизвестного количества переменных в функцию, но именовать их именно так не обязательно.

*args, *\*kwargs можно комбинировать, но в таком случае порядок важен и первым идет *args, затем *\*kwargs.



## Область видимости переменных

> Выше давалось описание функций, как их создавать и использовать. Будет правильным дать описание возможности применять переменные внутри функций с точки зрения области видимости.

В Python различают глобальные и локальные переменные.

*Глобальные (global) переменные* — это переменные, объявленные вне функций или внутри глобальной области видимости.

Это означает, что переменная доступна снаружи и внутри функции:

```python
x = "global"
def foo():
    print("x inside :", x)
foo()
print("x outside:", x)
```

При запуске получим:

```python
x inside : global
x outside: global
```

Мы получили доступ к переменной **x** внутри функции **foo()** и снаружи от нее.
Но стоит отметить интересный момент, что при попытке изменить эту переменную внутри функции **foo()** мы получим ошибку.

```python
x = "global"
def foo():
    x = x * 2
    print(x)
foo()
UnboundLocalError: local variable 'x' referenced before assignment
```

Это происходит потому, что при изменении переменной функция ищет ее внутри локальной области видимости, но не находит ее первичного определения. Чтобы исправить эту ошибку следует использовать ключевое слово **global**:

```python
x = "global"
def foo():
    global x
    x = x * 2
    print(x)
foo()
```

*Локальные (local) переменные* — это переменные, определяемые внутри функций / методов классов, которые используются только внутри этих функций:

```python
def foo():
    y = "local"
    print(y)
foo()
```

Python гибкий язык, он позволяет создавать функции внутри функций и т.д.

Например:

```python
def foo():
    def under_foo()
        print("in foo")
    under_foo()
foo()
```

Применимо к функции **under_foo()** можно описать нелокальную переменную, используя ключевое слово **nonlocal**.

Это означает, что переменная не может быть ни в локальной, ни в глобальной области видимости.

```python
def outer():
    x = "local"
    def inner():
        nonlocal x
        x = "nonlocal"
        print("inner:", x)
    inner()
    print("outer:", x)
outer()
```

При запуске получим:

```python
inner: nonlocal
outer: nonlocal
```

Тут внутри функции **inner()** мы определяем нелокальную переменную **X**. Функция **inner()** определена в области видимости функции **outer()**, поэтому, используя ключевое слово **nonlocal**, меняется значение локальной переменной **X** функции **outer()**.



### Как применять локальные / глобальные переменные на практике?

На практике хорошим тоном является использование глобальных переменных в качестве констант, например, для заведения строковых переменных и использование их в качестве ключей словаря.

В крупном проекте изменение глобальных переменных внутри функций приводит к неприятным и сложно уловимым ошибкам.

Использование **nonlocal** переменных оправдано, когда код вложенной функции короток и логичен. Но обычно на практике применение вложенных функций ведет к усложнению кода и последующему рефакторингу.



## Lambda-выражения

> Выше дано описание «классических» функций в Python, но существуют еще и анонимные функции. Lambda-выражения — это синтаксический сахар в Python, необходимый для создания анонимных / lambda функций.

*Lambda-исчисления* / *lambda-функции* изначально были характерны для функциональных языков программирования, таких как Haskell, Lisp, Erlang.

И хоть Python императивный язык, он забрал частичку их функциональности.



### Полезная ссылка

Подробная информация о [функциональных языках программирования](https://ru.wikipedia.org/wiki/Функциональное_программирование).



Lambda-функции в Python определяются следующим способом:

```python
>>> lambda x: x + 1
```

где:

**lambda** - ключевое слово;

**x** - входной аргумент;

**x + 1** - действия над аргументом.

```python
>>> (lambda x: x + 1)(2)
3
```

т.к. это функция, то ее можно вызывать:

```python
>>> add_one = lambda x: x + 1
>>> add_one(2)
3
```

а так же присвоить переменной.



### Применение lambda-функций на практике

На практике lambda-функции часто используются в качестве аргумента другой функции.

Например, при использовании функции **sorted()**:



```python
colors = ["Goldenrod", "purple", "Salmon", "turquoise", "cyan"]
print(sorted(colors, key=lambda s: s.casefold()))
# Результат: ['cyan', 'Goldenrod', 'purple', 'Salmon', 'turquoise']
```

В других случаях применения lambda оправдано, если:

- Внутри метода класса / функции нужно выполнить несколько раз простую операцию, которую нет желания выносить в отдельную функцию.
- Наличие lambda-функции делает код более понятным.
- Твой коллега также понимает зачем нужно использовать lambda.



## Рекурсия

> Рекурсия — это вызов функции самой себя. Особенностью рекурсии является базовое условие — это условие, которое завершит цикл, если оно выполнено, в этом случае рекурсивная функция завершает свою работу. 

Например:

```python
def getTotal(n, total):
    print n
    if n == 0: # base condition
        return total
    else:
        return getTotal(n-1, (total+(n)))print getTotal(5, 0)
```

В python есть возможность задать лимит на количество вызовов рекурсивной функции:

```python
import sys 
sys.setrecursionlimit(10**6)
```



### Рекурсия на практике

На практике рекурсивные функции применяются для решения задач, связанных с обходом дерева / графа и т.п. 

При разработке backend-систем стоит осторожно подходить к применению рекурсии, т.к. код становится более сложным для понимания другими программистами. Возможны случаи, когда система, получив неправильные данные, войдет в бесконечную рекурсию и завершится с ошибкой.



## Декораторы

> Декоратор — это в первую очередь структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту.

В Python этот механизм вынесен на уровень синтаксического сахара благодаря нескольким особенностям языка.

1. Функция - это объект, ее можно присвоить переменной:

```python
def example_function(param1 = "test"):
    return param1
print(example_function())
variable = example_function
print(variable())
```

2. Функция может быть определена внутри другой функции: 

```python
def example_function():
    def under_function(param1)
        print(param1)
    print(under_function("test"))
example_function()
```

3. Функция может вернуть функцию как результат своей работы:

```python
def example_function():
    def under_function(param1)
        print(param1)
    return under_function
variable = example_function()
print(variable("test"))
```

4. Функция может принимать другую функцию в качестве входного параметра:

```python
def print_func():
    print("i am just printing")
def example_function(func):
    print("print before func")
    func()
    print("print after func")
example_function(print_func)
```

Комбинируя вышеперечисленные особенности, можно создать "свой" декоратор, не прибегая к сахару Python:

```python
def self_decorator(function_to_decorate):
    def wrap_original_function(): # объявляем вложенную функцию
        print("before")
        function_to_decorate() # вызываем оригинальную функцию
        print("after")
    return wrap_original_function # возвращаем функцию в качестве результата работы
def easy_function(): # определяем простую функцию
    print("i am just printinng this")
decorated_function = self_decorator(easy_function) # декорируем функцию
decorated_function()
```

Но, используя синтаксис декораторов, можно переписать предыдущий пример более коротко:

```python
@self_decorator
def easy_function():
    print("i am just printing this")
easy_function()
```

Конечно, можно использовать не только одну функцию в качестве декоратора, а использовать целую иерархию декораторов:

```python
@memory_decorator
@time_decorator
@self_decorator
def easy_function():
    print("i am just printinng this")
easy_function()
```

При этом важен порядок. Функция **easy_function()** будет обернута сначала **@self_decorator**, затем **@time_decorator**, потом **@memory_decorator**.

Т.к. внутри декораторов лежат функции Python, можно легко передавать аргументы внутрь декорируемой функции:

```python
def self_decorator(function_to_decorate):
    def wrap_original_function(before_arg, after_arg):
        print(before_arg)
        function_to_decorate(before_arg, after_arg)
        print(after_arg)
    return wrap_original_function

@self_decorator
def easy_function(before_arg, after_arg):
    print("my args", before_arg, after_arg)

easy_function("this is before", "this is after")
```

Конечно, более логичным является использование ***args**, ***\*kwargs**, для применения декоратора к любым функциям:

```python
def self_decorator(function_to_decorate):
    def wrap_original_function(*args, **kwargs):
        function_to_decorate(*args, **kwargs)
    return wrap_original_function
```

Логично было предположить возможность передать аргументы в декоратор — ведь это функция. Такие декораторы называют — параметризированные декораторы:

```python
def parametarized_decorator(decorator_arg1, decorator_arg2):   
    print("my decorator args", decorator_arg1, decorator_arg2)
    def custom_decorator(func):
        def wrapped(function_arg1, function_arg2) :
            return func(function_arg1, function_arg2)
        return wrapped 
    return my_decorator

@parametarized_decorator("test1", "test2")
def easy_function(function_arg1, function_arg2):
    print(function_arg1, function_arg2)

easy_function("test4", "test5")
```

Нужно помнить, что Python исполняет декораторы только раз, когда первый раз подключает ваш скрипт. 



### Декораторы на практике

На практике декораторы удобно применять для расширения функционала сторонних библиотек / уже написанного кода в собственном проекте.

Удобно писать универсальные декораторы для обработки ошибок, логирования, замера времени работы функции.

В Python встроено множество различных стандартных декораторов — **@staticmethod**, **@classmethod**, **@functools.wraps**, описание которых будет дано в дальнейших модулях курса.



### Задание 1

Используя полученные знания о функциях, напишите функцию, которая вычисляет факториал числа N.

О факториале числа можно [узнать тут](https://ru.wikipedia.org/wiki/Факториал).
Попробуйте найти оптимальное решение данной задачи, используя метод мемоизации.

О мемоизации можно [узнать тут](https://ru.wikipedia.org/wiki/Мемоизация).

```python
import sys

def naive_factorial(n):
  if n == 0:
    return 1 # !n = 1
  else: 
    return n * naive_factorial(n-1)
  
def memo_factorial(n):
  """with memoisation"""
  memo_dict = {0:1}
  if n in memo_dict.keys():
    return memo_dict[n]
  else:
    val = n * memo_factorial(n-1)
    memo_dict[n] = val
    return val

def main(choice_algorithm = "memo_factorial", n):
  if choice_algorithm == "memo":
    print("factorial = ", memo_factorial(n))
  else:
    print("factorial = ", naive_factorial(n))

if __name__ == '__main__':
  main(sys.argv[1], int(sys.argv[2]))
  

```



### Задание 2

Напишите простой декоратор, который считает время выполнения функции и выводит его на экран, возьмите для единицы подсчета времени — секунды.

Усложните его, написав параметризированный декоратор, принимающий на вход строку, означающую, в каких единицах выводить время — часах / минутах / секундах / миллисекундах.

```python
import time

def time_decorator(func):
  def _inner(*args, **kwargs):
    start = time.time()
    result = func(*args, **kwargs)
    end = time.time() - start
    print("work time = ", end)
    return result
  return _inner

@time_decorator
def main(choice_algorithm = "memo_factorial", n):
  if choice_algorithm == "memo":
    print("run memo")
    print("factorial = ", memo_factorial(n))
  else:
    print("run naive")
    print("factorial = ", naive_factorial(n))
```



```python
def foo(**kwargs):
    for i in kwargs:
        print(i)
    for k,v in kwargs.items():
        print(v)

foo(name="Jonny", age=25)
```



# ООП

## Основы классов

*Объектно-ориентированное программирование* — это парадигма разработки ПО, которая структурирует программу таким образом, что поведение и свойства сущностей объединяются в классы, конкретными реализациями которых являются объекты.

Например: парковка с различными средствами передвижения. Класс — авто, класс — мотоцикл, у них есть свойства: марка, цвет, местоположение на парковке, есть поведение: начать движение, остановиться и т.д. Конкретные объекты этих классов — синий «Мерседес» на месте 11а или черный мотоцикл «Хонда» на месте 42б. 

Python является языком со множеством парадигм, помимо ООП, можно структурировать программы по методу процедурного программирования. Все зависит от технических требований к продукту.

> Для простейших вещей, например, таких как числа, строки и более сложные - списки, словари и т.д. в Python реализованы собственные классы, речь о которых шла в предыдущих модулях. Важно отметить, что класс представляет собой шаблон для создания объектов, обеспечивающий начальные значения состояний: инициализация полей-переменных и реализация поведения функций или методов.

### Объекты (инстанс или экземпляр класса)

Это уже конкретная реализация класса, заполненная пользовательскими данными и имеющая поведение, описанное в классе.

Например, **dict**, заполненный несколькими значениями — это конкретный объект соответствующего класса, другой **dict** с другим набором значений — другой объект.

#### Как создать класс в Python?

```python
class Cat:
    pass
```

Используя ключевое слово **class** создается класс с названием **Cat**, после произвольного имени всегда следует двоеточие. 

Ключевое слово **pass**, как во многих других местах, используется в качестве заглушки, то есть мы реально не добавляем новых свойств в класс. Но без использования **pass** Python выкинет ошибку.



## Атрибуты, методы

### Атрибуты объекта

Чтобы добавить объекту вашего класса свойства, нужно реализовать метод **__init__()**:

```python
class Auto:
    def __init__(self, model, year):
        self.model = model
        self.year = year
```

где:

**self** — это указатель на сам объект;

**model**, **year** — это переменные, которые передаются внутрь объекта при вызове метода **__init__()**. Они могут быть числами, строками, другими классами, функциями, объектами и т.д.;

**self.model = model** и **self.year = year** — это создание атрибута объекта.

Метод не нужно специально вызывать, он вызывается автоматически при создании объекта класса.

### Атрибуты класса

Создавая атрибуты объекта, вы делаете объект уникальным, например, каждое авто уникально и имеет свою модель и год выпуска. Но есть атрибуты, которые свойственны всем авто, например — количество колес:

```python
class Auto:
    wheel_count = 4
    def __init__(self, model, year):
        self.model = model
        self.year = year
```

#### Создание объекта класса

Выше мы определили класс **Auto**, чтобы создать объект, нужно написать название класса и передать туда необходимые параметры.

```python
new_nissan_auto = Auto(model="nissan", year="2020")
```

#### Как это работает?

Мы создаем объект класса **Auto** и присваиваем его переменной **new_nissan_auto**. При передаче двух аргументов: **model**, **year**, они присваиваются соответствующим переменным объекта **Auto** — **self** во время метода **__init__()**.

Собственно говоря, создание объекта в Python происходит в два этапа:

1. Создание объекта — магический метод **__new__()**.
2. Инициализация объекта с новыми атрибутами — магический метод **__init__()**.

Абстрактно это выглядит так:

```python
class Foo:
def __new__(cls):
    return super().__new__(cls)

def __init__(self):
    pass
```

Внутри метода **__new__()** средствами **return** вызывает создание объекта класса, посредством обращения к методу **__new__()** базового класса **object**, который является базовым классом для всех пользовательских классов в Python.

Затем вызывается метод **__init__()**, в котором уже происходит создание атрибутов объекта, как в примере с классом **Auto**.

Обычно на практике метод **__new__()** переопределять не нужно, т.к. хватает реализации метода **new()** класса **object**. Просто нужно знать, что он всегда вызывается, и держать это в голове.

### Методы объекта

Как говорилось выше, в классах можно не только описывать атрибуты объекта, но и определять его поведение, которое производит определенные действия над этими атрибутами. Такие действия называются методами объекта.

Так **__init__()** — это метод при котором объекту добавляются новые атрибуты:

```python
class Auto:
    wheel_count = 4
    def __init__(self, model, year):
        self.model = model
        self.year = year

    def print_model(self):
        print(self.model)

    def set_year(self, new_year="2019"):
        self.year = new_year
```

В этом примере мы реализовали два новых метода:

**print_model()** — печатает в консоль модель авто;

**set_year()** — позволяет изменить год выпуска авто.

Ключевое слово **def** используется так же, как и при создании функций, но, в отличие от функций, первым атрибутом всегда идет **self**, хоть и явно он не передается.

В остальном методы похожи на функции в Python, есть возможность:

1. Указывать обязательные аргументы:

```python
def set_year(self, new_year):
    self.year = new_year
new_auto.set_year(2021)
```

2. Создавать аргументы по умолчанию:

```python
def set_year(self, new_year="2019"):
    self.year = new_year
```

3. При вызове метода передавать параметры по ключу:

```python
new_auto.set_year(new_year="2021")
```

4. Использовать переменное количество аргументов *args, **kwargs:

```python
def set_year(self, *args, **kwargs):
    pass
```

### Методы класса

По аналогии с атрибутами объекта/класса существуют методы класса: 

```python
class MyClass:
    class_const = "new const"

    @classmethod
    def method(cls, arg):
        print('classmethod - %s %s' % (arg, cls.class_const ))
```

В Python, чтобы создать метод класса, нужно использовать декоратор **@classmethod** и первым аргументом передавать не **self**, как в случае с объектом, а **cls** — то есть указатель на сам класс.

Как и в случае с методами объектов, вызов метода класса не подразумевает явной передачи аргумента **cls**:

```java
MyClass.method("call class method")
```

Особенностью использования классовых методов является возможность получить доступ к переменным класса.

На практике классовые методы создаются для операций над классовыми атрибутами, то есть те случаи, когда создание объекта не нужно.

#### Декоратор @staticmethod

**@staticmethod** — это возможность в Python сделать статический метод, т.е. метод, который можно вызвать как используя класс, так и используя объект класса, но при этом в первом случае нет доступа к переменным класса, а во втором нет доступа к переменным объекта.

```python
class Сalculator:
    @staticmethod
    def sum(x1, x2):
        return x1 + x2
c = Сalculator()
print(c.sum(2,2))
print(Сalculator.sum(1,2))
```

Вывод:

```python
4
3
```

#### Декоратор @property

**@property** — это возможность Python преобразовать метод класса в атрибут с доступом только для чтения. 

```python
class Student:
    def __init__(self, fullname):
        self._full_name = fullname
    
    @property
    def fullname(self):
        return self._full_name

    @fullname.setter
    def fullname(self, value):
        self._full_name = value

s = Student("Tom Hanks")
print(s.fullname)
s.fullname = "Bob Dylan"
print(s.fullname)
```

Вывод:

```python
Tom Hanks
Bob Dylan
```

В этом примере мы, используя **@property**, делаем доступ для внутреннего атрибута **_full_name**, используя конструкцию **@<метод обернутый property>.setter**, устанавливаем возможность изменять этот атрибут.



## Инкапсуляция

> Инкапсуляция, наряду с наследованием и полиморфизмом, — один из трех китов ООП.

*Инкапсуляцию* правильно рассматривать с двух точек зрения:

1. Это связь данных с методами, которые эти данные используют.
2. Это управление доступом к данным и методам, которые эти данные используют.

Объяснение инкапсуляции как связи простое — это может быть любой класс, в котором существуют атрибуты и существуют методы, которые эти атрибуты используют. Ведь никто не запрещает создать класс без пользовательских методов и класс с методами, но без пользовательских переменных.

Конечно, обычно инкапсуляцию подразумевают как управление доступом к методам и данным. Доступ в этом случае — это возможность видеть / изменять атрибуты и методы класса. 

В Python можно выделить три уровня доступа данным:

- **public** — доступно всем;
- **private** — доступно только внутри класса;
- **protected** — доступно внутри класса и внутри классов наследников.

Уровень **public** — это уровень по умолчанию, не нужно использовать особые конструкции, чтобы сделать атрибут или метод публичным. См. пример класса **Auto**.

Чтобы сделать атрибут или метод **protected**, нужно добавить один символ **_** перед названием:

```python
class Auto:  
    wheel_count = 4
    def __init__(self, model, year, price):
        self.model = model
        self.year = year
        self._price = price
```

Чтобы сделать атрибут или метод **private**, нужно добавить два символа **__** перед названием:

```python
class Auto:    
    wheel_count = 4
    def __init__(self, model, year, price, model_description):
        self.model = model
        self.year = year
        self._price = price
        self.__secret_description = model_description
```

Хотя при прямом доступе и произойдет ошибка, в Python регулирование инкапсуляции — это лишь условность и договоренность:

```python
class BankCard:
    __serial_number = "1111 2222 3333 4444" # private-переменная
    __pin = 955 # private-переменная

    def __get_pin(self): # private-метод
        print( "My pin is : ", self.__pin)
bank_card = BankCard()
bank_card._BankCard__get_pin()
bank_card._BankCard__serial_number = "2222 3333 4444 66666"
print( "New serial number is ", bank_card._BankCard__serial_number )
```

Проектируя классы, нужно заранее думать, какие атрибуты и методы оставить публичными, а какие закрыть, ведь не нужно отдавать все внутренности на доступ другим разработчикам. 

И хоть в Python регулирование доступа — это договоренность, соблюдение ее всеми членами команды необходима и является хорошим тоном.



## Наследование и MRO

> Наследование — это принцип ООП, позволяющий описать новый класс на основе уже существующего.

Класс, от которого производится *наследование*, называется *базовым* или *родительским*. Новый класс — *потомком*, *наследником* или *производным классом*. При этом класс-наследник получает в свое распоряжение методы и переменные базового класса.

В python3 все классы неявно наследуются от класса **object**:

```python
>>> class MyClass:
... pass
>>> c = MyClass()
>>> dir(c)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__',
'__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__',
'__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__',
'__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',
'__str__', '__subclasshook__', '__weakref__']
```

То есть все пользовательские классы уже имеют набор стандартных переменных и методов:

```python
class Cat:

    def __init__(self, first_name, last_name="Cat"):
        self.first_name = first_name
        self.last_name = last_name

    def meow(self):
        print("The cat is meow.")
```

Создали базовый класс **Cat** и определили несколько методов:

```python
class MainCoon(Cat):
    pass

main_coon = MainCoon("Lisa")
print(main_coon.first_name + " " + main_coon.last_name)
main_coon.meow()
```

Создали новый класс **MainCoon** и унаследовали от класса **Cat**, видим, что при вызове исполняются методы базового класса. Но данный пример очень простой, так как обычно при наследовании программист переопределяет методы базового класса и пишет свои, тем самым расширяя функционал. Но при конструировании родительских и дочерних классов важно учитывать дизайн программы, чтобы переопределение не приводило к ненужному или избыточному коду:

```python
class Tiger(Cat):
    def __init__(self, first_name, last_name="Cat",
            color="orange_with_black", location="Russia"):
        self.first_name = first_name
        self.last_name = last_name
        self.color = color
        self.location = location

    def print_tiger_location(self):
        print(self.location)
```

В данном примере есть одна особенность, мы просто сделали наследование от класса **Cat**, при этом мы полностью переопределили **__init__**. Но часто бывает удобно сначала вызвать метод базового класса, а затем дополнить его логикой класса наследника:

```python
class Tiger(Cat):
    def __init__(self, first_name, last_name="Cat",
            color="orange_with_black", location="Russia"):
        super().__init__(first_name, last_name)
        self.color = color
        self.location = location

    def print_tiger_location(self):
        print(self.location)
```

Тут нам поможет ключевое слово **super**, которое позволяет обратиться к классу-предку, вызвать его метод и передать в него необходимые аргументы.

Помимо наследования с одним предком, Python поддерживает множественное наследование — это когда класс может наследовать атрибуты и методы от нескольких родительских классов.

Также существует частный случай множественного наследования, когда методы и атрибуты родительских классов не перекрывают друг друга — это называется *MixIn*.

```python
class FlyingDuck:

    def fly(self):
        print("I am flying duck")

class RedDuck:

    def color(self):
        return "red"

class RedFlyingDuck(FlyingDuck, RedDuck):
    pass
```

Опасность, которую несет множественное наследование, — это шанс запутаться, так в этом случае Python применяет принцип MRO для вызова метода базовых классов. Также код становится тяжело поддерживаемым, т.к. изменения в одном из классов-родителей могут быть критичны для классов-наследников.

### Method Resolution Order

*Method Resolution Order (MRO)* — это порядок, в котором Python ищет метод в иерархии классов.

Разберем на примерах.

#### Пример 1

![img](https://cs.sberbank-school.ru/image/1000/auto/upsize/d0274a64-5bf7-11eb-8840-0242ac160005)

```python
class A:
    def process(self):
        print("A process()")

class B:
    pass

class C(A, B):
    pass

obj = C()     
print(C.mro())
```

Метод **mro()**, доступный по умолчания для классов, возвращает список, в котором он будет искать метод для выполнения, в случае, если метод не будет найден, произойдет ошибка.

```python
[<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
```

На этом примере мы можем видеть, что поиск происходит слева направо.

#### Пример 2

![img](https://cs.sberbank-school.ru/image/1000/auto/upsize/d0304b96-5bf7-11eb-87b3-0242ac180006)

```python
class A:
    def process(self):
        print("A process()")

class B:
    def process(self):
        print("B process()")

class C(A, B):
    def process(self):
        print("C process()")

class D(C,B):
    pass

obj = D()
print(D.mro())
[<class '__main__.D'>, <class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
```

Тут мы идем в глубину сначала по дереву первого предка, потом, т.к. предок **B** есть у класса **C**, повторно он не вызывается.

#### Пример 3

![img](https://cs.sberbank-school.ru/image/1000/auto/upsize/d0315a68-5bf7-11eb-826b-0242ac160006)

```python
class A:
    def process(self):
        print("A process()")

class B(A):
    pass

class C(A):
    def process(self):
        print("C process()")

class D(B,C):
    pass

obj = D()
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

В данном случае Python применяет хитрость и следующим образом меняет классы для поиска:

D -> B -> A -> C -> A

D -> B-> A -> object -> C -> A -> object

D -> B -> C -> A -> object

*Наследование* — это инструмент на котором держится грамотное проектирование системы, это умение выделить базовые сущности и, на их основе, сделать наследников, которые будут нести более узкоспециализированный функционал.

*Множественное наследование* обычно не применяется, так как приводит к ошибкам и усложнению кода. Единственные случаи, когда это оправдано, наследование от интерфейсов / абстрактных классов, которые не несут конкретной реализации, при этом базовые классы для наследника должны быть максимально различны, чтобы не было пересечений по методам или переменным.



## Полиморфизм

> Полиморфизм — это возможность классов изменять поведение, которое они унаследовали от базовых классов.

Когда несколько классов или подклассов имеют одинаковые имена методов, но разные реализации для одних и тех же методов, можно сказать, что классы полиморфны.

```python
class Person:
    def __init__(self, name, age):
        self.__name = name 
        self.__age = age

class Employee(Person):
    def __init__(self, name, age, company):
        Person.__init__(self, name, age)
        self.company = company
```

На этом примере мы можем видеть, что класс **Employee** полиморфно изменяет метод **__init__()**, добавляя туда еще одну переменную **company**. Также можно менять не только количество аргументов, но и их тип или тип возвращаемого значения.

*Полиморфизм* в коде обеспечивает слабую связанность и, благодаря этому, его можно легко расширять и поддерживать. С другой стороны, нужно аккуратно подходить к проектированию классов. Создавая полиморфные классы, унаследовав один от другого, следует грамотно переопределять функции, так, например, добавление новых переменных в функцию может привести к ошибке, т.к. эти переменные не передаются в метод базового класса.



## Абстрактные классы

> Абстрагирование — это выделение набора значимых характеристик сущности. Абстракция — это набор всех таких характеристик.

*Абстрактным* называется класс, который содержит один и более абстрактных методов. Абстрактным называется объявленный, но не реализованный метод. Невозможно создать объекты абстрактных классов, от них нужно отнаследоваться и реализовать все их абстрактные методы, и только тогда можно создать экземпляр такого класса. В Python отсутствует встроенная поддержка абстрактных классов, для этой цели используется модуль **abc** (Abstract Base Class):

```python
from abc import ABC, abstractmethod
class ChessPiece(ABC):
    # общий метод, который будут использовать все наследники этого класса
    def draw(self):
        print("Drew a chess piece")

    # абстрактный метод, который будет необходимо переопределять для каждого наследника
    @abstractmethod
    def move(self):
        pass

a = ChessPiece()

# получим ошибку:
class Queen(ChessPiece):
    def move(self):
        print("Moved Queen to e2e4")

# Мы можем создать экземпляр класса
q = Queen()

# И нам доступны все методы класса
q.draw()
q.move()
```

Абстрактный метод может быть реализован сразу в абстрактном классе, однако декоратор **abstractmethod** обязует в классе-наследнике реализовать собственную версию метода, либо дополнить существующую. 

```python
from abc import ABC, abstractmethod
class Basic(ABC):
    @abstractmethod
    def hello(self):
        print("Hello from Basic class")

class Advanced(Basic):
    def hello(self):
        super().hello()
        print("Enriched functionality")

a = Advanced()
a.hello()
```

Таким образом, используя концепцию абстрактных классов, мы можем улучшить архитектуру приложения, уменьшить объем работы и при этом, упростить дальнейшую поддержку кода.



## Магические методы

> Выше мы рассмотрели основные принципы ООП и работу с ними в Python. Далее погрузимся немного в особенности Python и посмотрим, что еще интересного можно сделать, проектируя классы.

*Магические методы* — это специальные методы, которые имеют двойное подчеркивание в начале и в конце своих имен.

Эти методы не вызываются вручную, Python это делает за нас.

Речь о идет о возможности совершать операции **==** , **in**, **<=** , **>=** и другие, которые так удобны при работе со встроенными классами.

**\__init__** — инициализация объекта класса

**\__del__(self)** — вызывается, когда сборщик мусора удаляет объект

**\__str__(self)** — когда вызывается функция **str()** применимо к объекту класса

**\__eq__(self, other)** — сравнение объекта через **==**

**\__add__(self, other)** — сложение через **+**

**\__sub__(self, other)** — вычитание через **-**

**\__int__(self)** — преобразование объекта функцией **int()**

**\__hash__(self)** — определение хеша объекта при вызове функции **hash()**

**\__len__(self)** — количество элементов в контейнере объекта

Пример:

```python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age
    def __str__(self):
        return self.__name + "/" + str(self.__age)
p = Person("Bob", 24)
print(str(p))
```

Вывод:

```python
Bob/24
```



### Полезная ссылка

[Отдельное руководство](https://rszalski.github.io/magicmethods/) по магическим методам, где дается описание всех возможных методов, доступных для переопределения в пользовательских классах.



## Слоты

Внутри классов Python, неявно для разработчика, создает словарь, в котором хранятся все атрибуты класса. Это позволяет модифицировать атрибуты объекта в ходе работы программы.

Пример:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def __str__(self):
        return self.name + "/" + str(self.age)
p = Person("Bob", 24)
print(p.__dict__)
```

Вывод:

```python
{'name': 'Bob', 'age': 24}
```

Но в некоторых случаях, когда создается большое количество небольших объектов, это может быть затратно по памяти. Решить проблему лишнего потребления памяти, а также возможность зафиксировать количество атрибутов в классе, позволяют *слоты* — **__slots__** .

В **__slots__** могут быть перечислены атрибуты, для значений которых требуется зарезервировать место, при этом словарь **__dict__** не будет создан, вместо него будет использовать кортеж.

Пример:

```python
class Person:
    __slots__ = ("name", "age")
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def __str__(self):
        return self.name + "/" + str(self.age)
p = Person("Bob", 24)
print(p.__dict__)
```

Вывод:

```python
AttributeError: 'Person' object has no attribute '__dict__'
class Person:
    __slots__ = ("name", "age")
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def __str__(self):
        return self.name + "/" + str(self.age)
p = Person("Bob", 24)
print(p.__slots__)
print(type(p.__slots__))
```

Вывод:

```python
('name', 'age')
<class 'tuple'>
```

Также слоты удобно применять в те моменты, когда класс разработан и его дальнейшее расширение не планируется, это может послужить дополнительной информацией для других разработчиков системы.



## Задание

Предлагаем спроектировать иерархию классов для банковской системы, где необходимо предусмотреть следующие классы:

- Пользователь системы 
- Администратор системы
- Электронный кошелек

Для себя ответьте на вопросы:

- Какие атрибуты будут у этих классов?
- Как связаны между собой классы **Пользователь системы** и **Электронный кошелек**?
- Как в этой системе применить абстрактные классы?
- Какие атрибуты можно декорировать с помощью **classmethod**, **staticmethod**, **property**?
- Возможно ли применить слоты в этой системе?
- Какие магические методы можно применить к классу **Электронный кошелек**?
- Какие атрибуты и методы класса **Администратор системы** будут закрытыми?



# Модули и пакеты

## Модули

Разделение на модули при разработке ПО позволяет:

- Внести простоту в разработку отдельных частей — можно абстрагироваться от всей системы и сосредоточиться на разработке конкретного модуля.
- Обеспечить логическое разделение и слабую связанность, таким образом, обеспечить легкую модификацию ПО в будущем.
- Возможность переиспользовать модули в различных частях системы или при разработке новой системы.
- Разделить пространства имен для предотвращения конфликтов.

Существуют несколько способов создания модуля в Python:

1. Модуль, написанный на Python.

2. Модуль как C-extention.

Для создания самого простого модуля на Python достаточно:

1. Создать файл c расширением .py.

2. Написать синтаксически правильный python-код.

```python
my_module.py
s = "this is Python course"
a = [100, 200, 300]
def foo(arg):
    print(arg)
class Foo:
    pass
```

В примере выше организовали простой модуль **my_module.py**, который содержит в себе строку, список, функцию, класс.

Используя ключевое слово **import**, можно подключить данный модуль:

```python
>>> import my_module 
>>> print(my_module.s) 
this is Python course 
>>> my_module.a 
[100, 200, 300] 
>>> my_module.foo(['1', '2', '3']) 
['1', '2', '3'] >
>> x = my_module.Foo() 
>>> x 
<my_module.Foo object at 0x03C181F0>
```

Как видим, мы подключили пользовательский модуль и работаем с ним, как со стандартным, встроенным в Python, модулем.



## Ключевое слово import

Как было указано выше, чтобы подключить модуль нужно использовать ключевое слово **import**.

В общем случае это выглядит так:

```python
import <module_name>
```

Для вызова переменных, функций, классов подключенного модуля нужно использовать точку, например:

```python
>>> mod.s
'this is Python course.'
>>> mod.foo("test")
"test"
```

Python поддерживает подключение нескольких модулей через запятую:

```python
import <module_name>[, <module_name> ...]
```

Часто бывает неудобно использовать конструкцию типа **module.variable**, поэтому существует возможность подключать переменные напрямую из модуля

```python
from <module_name> import <name(s)>
```

Например:

```python
>>> from mod import s, foo
>>> s
'this is Python course.'
>>> foo("test")
test
>>> from mod import Foo
>>> x = Foo()
>>> x
<mod.Foo object at 0x02E3AD50>
```

Используя такой подход, нужно помнить, что произойдет перекрытие областей видимости, что может привести к трудно уловимым ошибкам.

```python
>>> a = ['foo', 'bar', 'baz']
>>> a
['foo', 'bar', 'baz']
>>> from mod import a
>>> a
[100, 200, 300]
```

Так же есть возможность подключить абсолютно все объявленные переменные, функции и классы из модуля, используя следующую конструкцию:

```python
from <module_name> import *
```

Например:

```python
>>> from mod import *
>>> s
'this is Python course'
>>> a
[100, 200, 300]
```

Бывают случаи, когда имена классов или других переменных пересекаются внутри разных модулей, а использовать их нужно совместно, или же другой разработчик дал непонятное имя, которое хочется исправить под себя, для этого существует отдельные конструкции.

Такая используется для переименования внутренних объектов модуля:

```python
from <module_name> import <name> as <alt_name>[, <name> as <alt_name> …]
```

А такая для переименования самого модуля:

```python
import <module_name> as <alt_name>
```



## Модуль importlib

Данный модуль стандартной библиотеки python обеспечивает реализацию оператора import Python, а также функции **__import__()**.

Позволяет динамически загружать модули и дает возможность создать собственный импортер для реализации кастомной загрузки модулей.

#### Динамический импорт

**Importlib** поддерживает динамическое импортирование модулей и позволяет загрузить модуль, имя которого было передано строкой. 

Например:

```python
foo.py
def main():
    print(__name__)
dynamic_import_module.py
import importlib
def dynamic_import(module):
    return importlib.import_module(module)
if __name__ == '__main__':
    module = dynamic_import('foo')
    module.main()
```

Поиск модуля **foo** осуществляется по тем же правилам, что и при использовании оператора **import**.  

Проверка на возможность импорта модуля осуществляется следующим образом:

```python
import importlib.util
def check_module(module_name):
    module_spec = importlib.util.find_spec(module_name)
    if module_spec is not None:
        print('Module: {} can be imported!'.format(module_name))
        return module_spec
def import_module_from_spec(module_spec):
    module = importlib.util.module_from_spec(module_spec)
    module_spec.loader.exec_module(module)
    return module
if __name__ == '__main__':
    module_spec = check_module('collections')
    if module_spec:
        module = import_module_from_spec(module_spec)
        print(dir(module))
```

Если, используя **importlib.import_module**, на вход мы передавали строку, то тут мы сначала, используя **importlib.util.find_spec,** пробуем найти спецификацию модуля, а затем, если она найдена, используя **importlib.util.module_from_spec,** загружаем модуль и в **module_spec.loader.exec_module** исполняем его.

Так же **importlib** поддерживает загрузку спецификации модуля по пути и имени.

```python
module_spec = importlib.util.spec_from_file_location(
    module_name, module_file_path
)
```

Если спецификация найдена, модуль можно загрузить, используя известные механизмы из примера выше.

Резюмируя, хочется отметить, что модуль **importlib** используется не часто, т.к. он привносит неявные (динамические) возможности подгрузки модулей, от этого он находит свое применения в задачах, когда необходимо выполнить какие-либо действия в момент загрузки модуля, хитро создать фабрику классов и т.д. Он может быть полезен при создании систем, которые на вход принимают python-файлы, проверяют их и исполняют, например, системы спортивного программирования — hackerrank.com и похожие.



## Пакеты

Во время разработки ПО, использования одних лишь модулей недостаточно, т. к. проект растет, хочется выделить отдельные модули внутрь логически обособленных единиц — этим в python являются *пакеты*. 

Так же, как модули позволяют избежать коллизии имен, пакеты позволяют избежать коллизий внутри имен модулей.

Иерархически пакеты строятся вокруг обычных папок операционной системы.

```python
pkg # Папка в ОС
- mod1.py 
- mod2.py
- __init__.py
mod1.py
def foo():
    print('module1 foo()')
class Foo:
    pass
mod2.py
def bar():
    print('module2 bar()')
class Bar:
    pass
```

Учитывая нашу иерархию, нужно убедиться, что пакет находится в списке путей, по которым будет искать python во время запуска, **sys.path**, **PYTHONPATH** и т.д. Если все это соблюдено, то импортировать модуль из пакета очень просто:

```python
import <module_name>[, <module_name> ...] # импорт модулей
>>> import pkg.mod1, pkg.mod2
>>> pkg.mod1.foo()
module 1 foo()
>>> x = pkg.mod2.Bar()
>>> x
<pkg.mod2.Bar object at 0x033F7290>
from <module_name> import <name(s)> # импорт конкретных объектов из модуля
>>> from pkg.mod1 import foo
>>> foo()
module 1 foo()
from <module_name> import <name> as <alt_name> # импорт с другим именем
>>> from pkg.mod2 import Bar as Qux
>>> x = Qux()
>>> x
<pkg.mod2.Bar object at 0x036DFFD0>
```

### Инициализация пакетов

Если внутри пакета создать файл **__init__.py**, то при импорте пакета или модуля из него выполнится и **__init__.py**.

Это может быть полезно для определения глобальных переменных, свойственных для пакета, определения функций и т.д. 

```python
pkg
- __init__.py
- mod1.py
- mod2.py
__init__.py
print("init in __init__.py")
A = ["tes1t", "test2"]
>>> import pkg
init in __init__.py
>>> pkg.A
["tes1t", "test2"]
```



## Создание собственного whl

Многие домашние (и не только) разработки приводят к тому, что созданным проектом хочется с кем-то поделиться. Для этого в Python придумали формат **whl**, сопутствующие утилиты, позволяющие упаковать проект для дальнейшего распространения.

Для этого мы создадим небольшую иерархию папок:

```python
python_course_package/ 
  example_pkg/ # пакет, который будем импортировать через import
    __init__.py
```

Внутрь **__init__.py** пропишем:

```python
print("test package")
```

Внутри папки **example_pkg** создадим файл **setup.py** c таким содержимым:

```python
import setuptools
setuptools.setup(
    name="python-course-package", # Replace with your own username
    version="0.0.1",
    author="Sberbank",
    long_description="test package",
    long_description_content_type="text/markdown",
    packages=setuptools.find_packages(),
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires='>=3.6',
)
```

**setup.py** - это скрипт для сборки с помощью библиотеки **setuptools**.



### Полезная ссылка

Более подробно о **setuptools** можно [узнать тут](https://packaging.python.org/key_projects/#setuptools).



После создания **setup.py** убедимся, что мы имеем последние версии библиотек для упаковки в **whl** с помощью команды:

```bash
python3 -m pip install --user --upgrade setuptools wheel
```

И теперь создадим новую библиотеку для Python. Из папки, где находится **setup.py,** вызовем команду:

```bash
python3 setup.py sdist bdist_wheel
```

Аргумент **sdist** создаст архив с библиотекой с дефолтным форматом для операционной системы — **tar.gz** для Unix подобных систем и **zip** для Windows.

Аргумент **bdist_wheel** создает дистрибутив библиотеки с расширением **whl**.

После отработки, получим следующие папки:

```bash
build example_pkg setup.py
dist python_course_package.egg-info
```

Упакованная библиотека находится в папке **dist**:

```bash
python-course-package-0.0.1.tar.gz python_course_package-0.0.1-py3-none-any.whl
```

C помощью **pip** установим библиотеку себе в Python:

```bash
pip install python_course_package-0.0.1-py3-none-any.whl
```

А теперь импортируем созданную библиотеку и увидим результат вызова метода **print()** в консоли:

```python
>>> import example_pkg
test package
```



# Итераторы и генераторы

## Итераторы

В первую очередь, *итератор —* это паттерн, позволяющий получить доступ к элементам объекта-агрегатора без использования описаний каждого из агрегированных объектов.

Основное назначение итераторов — это упрощение навигации по элементам объекта, в основе которых обычно лежит список, словарь, кортеж и т.д.

В Python *итератор* - это объект, который для данного элемента возвращает следующий элемент либо вызывает исключение, если элементов больше нет.

Основное применение итераторов в Python — это цикл **for**, который неявно для разработчика вызывает методы прохода по элементам объекта.

Пример цикла **for**:

```python
>>> num_list = [1, 2, 3, 4, 5]
>>> for i in num_list:
    print(i)
1
2
3
4
5
```

Воспользовавшись функцией **iter()**, можно получить объект итератора, а с помощью функции **next()** пройтись по элементам.

```python
>>> itr = iter(num_list)
>>> print(next(itr))
1
>>> print(next(itr))
2
>>> print(next(itr))
3
>>> print(next(itr))
4
>>> print(next(itr))
5
>>> print(next(itr))
Traceback (most recent call last):
  File "<pyshell#12>", line 1, in <module>
    print(next(itr))
StopIteration
```

При разработке пользовательских классов, поведение итераторов позволяет реализовать магические методы **__iter__()** и **__next__()**.

Метод **__iter__()** нужен, чтобы с объектом класса мог работать цикл **for**.

Метод **__next__()** возвращает новый элемент последовательности и генерирует **StopIteration**, если последовательность закончилась.

Пример:

```python
class SimpleIterator:
    def __iter__(self):
        return self

    def __init__(self, limit):
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return 1
        else:
            raise StopIteration
```



## Оператор yield

### Генераторы

В Python *генератором* можно назвать языковую конструкцию, которая является функцией с использованием внутри ключевого слова **yield**, или генераторное выражение. Внутри генератора определены методы **__iter__()** и **__next__()**, с этой точки зрения в Python любой генератор является итератором. Различие кроется в том, что *итераторы* — это перебор элементов коллекции, а генератор — это создание, обработка и возвращение на дальнейшую обработку элемента.

Например, функция **range(start, stop, step)** является генератором, который создает последовательность чисел с определенным шагом. В каждый момент времени разработчик знает только текущий элемент, так как только этот элемент хранится в памяти.

В Python2 функция **range()** создает сразу все элементы и возвращает их для итерирования, то есть не является генератором, а вот функция **xrange()** уже является генератором и аналогом функции **range()** из Python3.

#### Оператор yield

Любая функция в Python, в теле которой встречается ключевое слово **yield**, называется генераторной функцией — при вызове она возвращает объект-генератор.

Объект-генератор реализует интерфейс итератора, соответственно, с этим объектом можно работать, как с любым другим итерируемым объектом.

В следующим примере используется **yield** для создания объекта-генератора:

```python
def gen_fun():
    print('block 1')
    yield 1
    print('block 2')
    yield 2
    print('end')
for i in gen_fun():
    print(i)
# block 1
# 1
# block 2
# 2
# end
```

Сначала создается объект-генератор, затем **for** получает итератор посредством **iter**, после в цикле неявно вызывается **next()**, при каждом вызове которого работа функции возвращается на то место, где был вызван последний **yield**.



## Менеджер контекста

Каждому разработчику в ходе своей работы приходилось использовать файлы для чтения / записи, работать с сокетами или http-соединением. Обычно это выглядит так:

```python
f = open("file.txt", "r")
data = f.read()
f.close()
```

Для упрощения кода, когда нужно что-то «открыть», произвести логику, «закрыть», в Python реализовали синтаксический сахар — *контекстные менеджеры*.

*Менеджер контекста* в Python — это объект класса, который реализует внутри себя магические методы **__enter__()** и **__exit__()**, благодаря которым объект можно использовать с оператором **with**.

Когда выполнение программы доходит до места с оператором **with**, вызывается метод **__enter__()** объекта, обычно в нем реализуют логику подключения к БД, открытие соединения и т.д., после выполняется код внутри блока **with**, а в конце блок **__exit__()**.

Так выглядит открытие файла с помощью контекстного менеджера и оператора **with**:

```python
with open(path, 'w') as f_obj:
    f_obj.write(some_data)
```

Добавить к классу поведение контекстного менеджера можно, реализовав методы **__enter__()** и **__exit__()**. Рассмотрим класс для подключения к базе данных:

```python
import sqlite3
    class DataConn:
        def __init__(self, db_name):
            """Конструктор"""
            self.db_name = db_name
        def __enter__(self):
            """
            Открываем подключение с базой данных.
            """
            self.conn = sqlite3.connect(self.db_name)
            return self.conn   
        def __exit__(self, exc_type, exc_val, exc_tb):
            """
            Закрываем подключение.
            """
            self.conn.close()
            if exc_val:
                raise
```

Метод **__exit__()** в отличие от **__enter__()** принимает три аргумента — тип класса ошибки, значение ошибки и трассировка ошибки. Эти аргументы будут равны **None,** если внутри блока **with** не будет ошибок. 

Если **__exit__()** вернет **True**, то в случае ошибки внутри блока **with** она не распространится дальше. Если вернет **False**, то ошибка распространится дальше, это свойство можно гибко использовать для случаев, когда произошедшая ошибка критична для данной системы.



## Генераторные выражения

В Python *генераторные выражения (generator expression)* — это синтаксический сахар для создания объекта-генератора без необходимости создания функции с **yield** внутри.

Например:

```python
a = (i for i in range(10000000))
```

создаст объект-генератор из функции **range()** и присвоит это переменной **a**.

Синтаксисом они схожи с *list comprehension*, которые были рассмотрены в модуле про структуры данных.

```python
[i for i in range(10000000)]
```

Они отличаются тем, что генераторное выражение не создаст в памяти сразу всю структуру, а будет каждый раз вычислять новый элемент. Тем временем, *list comprehension* сразу создаст всю структуру в памяти, что может отразиться в худшую сторону при работе вашей системы.



## Задание

В этом модуле была описана стандартная функция **range()**, более подробно о ней можно [прочитать тут](https://docs.python.org/3/library/functions.html#func-range).

Предлагаем в качестве практики реализовать собственную функцию **range()**, используя материал из данного модуля. Необходимо предусмотреть корректную работу функции при генерации значения как с положительным шагом, так и отрицательным, например:

start = 0; stop = 5; step = 1 — вывод: 0,1,2,3,4

start = 5; stop = 0; step = -1 — вывод: 5,4,3,2,1

Если введены некорректные значения, то предусмотреть правильную обработку и сообщение об этом.



# Контекстные менеджеры

## Модуль contextlib

В Python можно создавать контекстные менеджеры не только используя магические методы **__enter__()** и **__exit__()**, но и используя модуль **contextlib**.

Данный модуль несет в себе декоратор **contextmanager**, который привносит в функцию поведение контекстного менеджера.

```python
from contextlib import contextmanager

@contextmanager
def file_open(path):
    try:
        file = open(path, 'w')
        yield file
    except Exception:
        print("Error!")
    finally:
        print('Closing file')
        file.close()
```

Тут ключевой особенностью является логическое разделение пользовательской функции на этапы.

Первый этап: до оператора **yield** идет логика, схожая логикой внутри метода **__enter__()**, который нужно было бы реализовать внутри класса. 

Второй этап: оператор **yield** возвращает нужный объект, который используется внутри блока **with**.

Третий этап: после выполнения блока **with** следует этап очистки ресурсов и обработки ошибок.



## Задание

Предлагаем реализовать собственный контекстный менеджер на основе одного из классов, реализованного в рамках модуля про ООП или же создать собственный класс из предложенных на выбор:

- Подключение и выполнение операций к базе данных **sqlite** 
- Подключение и загрузка / скачивание файлов из хранилища **s3**
- Открытие и закрытие файла в ОС

Рекомендуем предусмотреть ошибки, которые могут возникнуть в ходе работы и обработать их в методе **__exit__()**.

[Описание модуля](https://docs.python.org/2/library/sqlite3.html) для подключения к **sqlite**.

[Описание модуля](https://github.com/boto/boto) для подключения к **s3**.



# Обработка ошибок

## Синтаксические ошибки

В Python, как и во многих других языках программирования, программа приостанавливает свою работу, если происходит ошибка, обработка которой не предусмотрена в программе. 

В Python можно выделить два типа ошибок:

1. Синтаксические ошибки, которые происходят из-за ошибок в синтаксисе Python.
2. Ошибки во время исполнения программы — они же исключения.

> Частые ошибки, которые преследуют разработчика во время программирования, — это *синтаксические*.

Они обычно происходят из-за невнимательности — лишняя скобка, микс пробелов и табов в файле, орфографические ошибки при написании операторов и т.д.

```python
>>> print(0 / 0))
  File "<stdin>", line 1
    print(0 / 0))                  
```

Вывод:

```python
SyntaxError: invalid syntax
```

Это произошло из-за лишней скобки в функции **print()**.

Такие ошибки быстро исправляются, а **PyCharm** имеет встроенную аналитику синтаксиса, что позволяет до запуска программы исправить допущенные неточности.



## Класс Exception, основные виды ошибок

### Exception

Ошибки во время исполнения программы в Python принято называть *exception* или *исключением*.

Такие ситуации характеризуются неверной логикой работы программы и говорят о том, что не все возможные ситуации обработаны корректно.

```python
>>> print(0 / 0)
```

Вывод:

```python
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
```

Тут происходит деление на **0**, что приводит к весьма очевидному исключению. Если бы в знаменателе вместо нуля была переменная, это говорило бы разработчику, что нужно добавить проверку на это краевое условие.

Но не только Python может порождать исключения во время работы программы, разработчик, используя ключевое слово **raise** может побудить собственное исключение:

```python
x = 10
if x > 5:
    raise Exception('x should not exceed 5. The value of x was: {}'.format(x))
```

Вывод:

```python
Exception: x should not exceed 5. The value of x was: 10
```

После **raise** не обязательно должен идти класс исключения, но это является распространенной практикой, т.к. позволяет более точно описать исключительную ситуацию в системе.

В Python базовым классом для исключений является класс **BaseException**.

```python
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      ...
      +-- Warning
```

**SystemExit** — исключение, порождаемое функцией **sys.exit()** при выходе из программы.

**KeyboardInterrupt** — прерывание программы пользователем (обычно с помощью **Ctrl+C**).

**GeneratorExit** порождается при вызове метода **close()** объекта **generator**.

**Exception** является базовым классом для исключений, отличных от системных (**SystemExit**, **KeyboardInterrupt**, **GeneratorExit**).

Также от этого класса должны быть унаследован пользовательский класс при создании собственного класса исключения.



### Полезная ссылка

Более подробно об иерархии исключений можно [прочитать тут](https://airbrake.io/blog/python-exception-handling/class-hierarchy).



## Ключевые слова try, except

> Данные ключевые слова образуют блоки, внутри которых перехватываются исключения определенных типов.

Внутри **try** располагается «обычная» логика программы, внутри **except** — то, что нужно выполнить, если произошло исключение, например: логирование, запись в БД, прекращение работы и т.д.

```python
try: 
    print( x / y)
except ZeroDivisionError:
    print("Ooops y is zero")
```

Хорошей практикой является явное использование классов исключений, в нашем случае **ZeroDivisionError**.

Но параметр с классом исключения не является необязательным. Если он пропущен, то блок **try-except** будет перехватывать все исключения, порожденные в коде, то есть по умолчанию возьмет класс **Exception**.

```python
try: 
    print( x / y)
except:
    print("I catch all")
```

Также можно использовать несколько классов исключений:

```python
try: 
    print( x / y)
except ZeroDivisionError, ValueError, NumberError:
    print("Ooops y is zero")
```

Эти классы можно перечислить через запятую, но обычно используют конструкцию из нескольких блоков **except**, чтобы на каждый класс исключения реагировать уникально.

```python
try: 
    print( x / y)
except ZeroDivisionError:
    print("Ooops y is ZeroDivisionError")
except ValueError:
    print("Ooops y is ValueError")
except NumberError:
    print("Ooops y is NumberError")
```

При возникновении исключения идет проверка блоков **except** сверху вниз.

Особенностью работы блока **try** является то, что исполнение кода идет только до первого исключения.

```python
try: 
    print( x / y)
    raise ValueError
except ZeroDivisionError:
    print("Ooops y is ZeroDivisionError")
except ValueError:
    print("Ooops y is ValueError")
except NumberError:
    print("Ooops y is NumberError")
```

Это означает, что конструкцией **try-except** лучше оборачивать только тот код, в котором может произойти исключение, в идеале — одну строчку.

Также плохой практикой является использование внутри блока **except** ключевого слова **pass**, т.к. по сути — это подавление ошибки, что приводит к неуправляемому поведению в программе.

### Ключевое слово else в блоке try-except

Если вам необходимо выполнить какую-то дополнительную логику в случае, если исключение не произошло, то для этого в конструкции **try-except** можно использовать ключевое слово **else**.

```python
try: 
    print( x / y)
except ZeroDivisionError:
    print("Ooops y is ZeroDivisionError")
else:
    print("No error")
```

### Ключевое слово finally в блоке try-except

Часто необходимо выполнить код в любом случае, когда произошло исключение или нет, например — закрыть соединение с БД, закрыть файл, если во время его обработки произошло исключение. Для таких случаев предусмотрено ключевое слово **finally.**

```python
try: 
    print( x / y)
except ZeroDivisionError:
    print("Ooops y is ZeroDivisionError")
else:
    print("No error")
finally:
    print("its code always run")
```

Слова **else** и **finally**, в отличие от **try-except**, не являются обязательными и их использование ложится на усмотрение разработчика.



## Пользовательские классы ошибок

В Python существует большое количество встроенных классов исключений которых обычно достаточно для разработки. Но во время работы часто возникает необходимо отловить исключительную ситуацию, которая специфичная для конкретного проекта. Для этого можно создать собственный класс исключений:

```python
class MyExceptionClass(Exception):
    def __init__(self, text):
        self.txt = text
```

Для определения собственных исключений, необходимо, чтобы они напрямую или опосредованно были наследниками класса **Exception**.

```python
class MyExceptionClass(Exception):
    def __init__(self, text):
        self.txt = text
x = 10
try:
    if x == 10:
        raise MyExceptionClass("this is custom Exception")
except MyExceptionClass as mec:
    print(mec)
```

Вывод:

```python
this is custom Exception
```

В этом примере мы вызываем собственно исключение с помощью **raise** и перехватываем с помощью **try-except**. Так как внутри класса **Exception** переопределен метод **__str__()**, поэтому в блоке **try-except** мы можем распечатать объект класса через **print()**, а не обращаться к переменной **txt**.



## Задания

### Задание 1

[Самостоятельно изучить](https://docs.python.org/3/library/exceptions.html) стандартные классы исключений в Python, чтобы приобрести кругозор по основным исключениям, которые могут встретиться в Python.

### Задание 2

Написать класс для подключения к одной базе данных на выбор: **sqlite**, **postgresql**, **mysql**. Предусмотреть возможность выполнять SQL-запросы с помощью этого класса. Создать собственный класс исключений, который можно было бы применить в случае передачи некорректных параметров для выполнения SQL-запроса.



# Тестирование

## Зачем нужно тестировать свой код

Неотъемлемой частью разработки ПО является *тестирование*.

> Тестирование — это процесс, в результате которого происходит оценка того, что все части приложения работают ожидаемым образом.

Зачем нужно тестировать свой код?

1. *Наличие тестов* позволяет разным разработчикам из команды понять, что, после внесения нового функционала или изменения старого, в целом система не потеряла работоспособность.
2. *Создание лучшей архитектуры*: сильно связанные между собой куски приложения будет более сложно покрыть тестами, что должно дать толчок к рефакторингу, чтобы сделать приложение максимально простым и тестируемым.
3. *Улучшение качество кода*.
4. *Упрощение рефакторинга*: т.к. разработка ПО непрерывный процесс, это нормально, что система меняется со временем, хорошо написанные тесты позволяют более просто вносить изменения в проект.

Тесты бывают разных видов:

1. *End to end (e2e)* — тестирование системы от начала до конца, имитируется реальная работа приложения.
2. *Интеграционные тесты* — тестирование нескольких подсистем на предмет их корректной работы между собой. 
3. *Unit-тесты* — изолированные тесты для покрытия конкретного функционала — класса, функции и т.д.

Обычно на плечи разработчиков ложится написание *unit-тестов*, хорошей практикой является покрытие кода тестами на уровне не ниже 80%. Будет правильным писать тесты, которые покрывают не только самый очевидный функционал, но и краевые условия.



## Модуль unittest

Самым распространенным модулем для написания тестов является **unittest**, который встроен в стандартную библиотеку Python.

Принципы, которые используются в нем, легко переносятся в такие пакеты, как **nose**, **nose2**, **pytest**. 

Модуль **unittest** имеет несколько особенностей:

- Тесты пишутся, как методы внутри класса.
- Используются специальные функции **assert**, позволяющие сделать заключение об успешном или неудачном прохождении теста.

```python
import unittest
class TestSum(unittest.TestCase):
    def test_sum(self):
        self.assertEqual(sum([1, 2, 3]), 6, "Should be 6")
    def test_sum_tuple(self):
        self.assertEqual(sum((1, 2, 2)), 6, "Should be 6")
if __name__ == '__main__':
    unittest.main()
```

Вывод:

```python
.F
==============================================================
FAIL: test_sum_tuple (__main__.TestSum)
--------------------------------------------------------------
Traceback (most recent call last):
  File "test.py", line 10, in test_sum_tuple
    self.assertEqual(sum((1, 2, 2)), 6, "Should be 6")
AssertionError: 5 != 6 : Should be 6
--------------------------------------------------------------
Ran 2 tests in 0.000s
FAILED (failures=1)
```

Разберем пример:

1. Импортируется модуль **unittest**.

2. Класс **TestSum** наследуется от **unittest.TestCase**. 

3. Методы-тесты обязательно должны начинаться с прекфикса **test_**. 

4. Внутри можно использовать различные методы типа:

- assertEqual(a, b) — a == b
- assertNotEqual(a, b) — a != b
- assertTrue(x) — bool(x) is True
- assertFalse(x) — bool(x) is False

5. В функции **main()** необходимо вызвать **unittest.main()**.

Хорошей практикой является создание одного класса unit-теста на один тестируемый класс, именование подбирается соответствующее.



### Полезная ссылка

Более подробно о различных методах **assert** можно [узнать тут](https://docs.python.org/3/library/unittest.html#assert-methods).



#### Методы setUp() и tearDown()

Часто бывают случаи, когда необходимо выполнить какую-то логику до выполнения теста и после, например, подключиться к базе данных, а потом закрыть подключение.

Для этого в модуле **unittest** предусмотрены методы **setUp()** и **tearDown().**

```python
import unittest
class TestSum(unittest.TestCase):

    def setUp(self):
        print("actions before tests")

    def tearDown(self):
        print("actions after tests")

    def test_sum(self):
        self.assertEqual(sum([1, 2, 3]), 6, "Should be 6")

    def test_sum_tuple(self):
        self.assertEqual(sum((1, 2, 2)), 6, "Should be 6")

if __name__ == '__main__':
    unittest.main()
```

Вывод:

```python
actions before tests
actions after tests
actions before tests
actions after tests
F
===============================================================
FAIL: test_sum_tuple (__main__.TestSum)
---------------------------------------------------------------
Traceback (most recent call last):
  File "test.py", line 16, in test_sum_tuple
    self.assertEqual(sum((1, 2, 2)), 6, "Should be 6")
AssertionError: 5 != 6 : Should be 6
---------------------------------------------------------------
Ran 2 tests in 0.000s
```

По логам можем видеть, что методы **setUp()** и **tearDown()** выполняются каждый раз до и после каждого теста.



## Модуль Mock

Как говорилось выше, высокая связанность внутри модулей программы приводит к сложностям при написании unit-тестов. Облегчить жизнь разработчикам призван класс **unittest.Mock**.

> Mock — это объект в тестировании, который заменяет реальный объект, имитируя его поведение.

Например, при написании тестов к системе, в которой реализованы http-запросы к реальному сервису, будет целесообразно использовать Mock-объекты как результат ответа на определенный запрос. Т.к. легко может произойти ситуация, когда тест не будет проходить в силу отсутствия соединения с сервером / вернулся ответ в другом формате и т.д.

Чтобы создать Mock-объект, нужно:

```python
>>> from unittest.mock import Mock
>>> mock = Mock()
>>> mock
<Mock id='4561344720'>
```

Особенностью работы с **Mock** является создание объектов «на лету» во время первого обращения к ним:

```python
>>> mock.some_attribute
<Mock name='mock.some_attribute' id='4394778696'>
>>> mock.do_something()
<Mock name='mock.do_something()' id='4394778920'>
```

Внутри **Mock** хранится история использования данного объекта.

```python
>>> from unittest.mock import Mock
>>> json = Mock()
>>> json.loads('{"key": "value"}')
<Mock name='mock.loads()' id='4550144184'>
>>> json.loads.assert_called()
>>> json.loads.assert_called_once()
>>> json.loads.assert_called_with('{"key": "value"}')
>>> json.loads.assert_called_once_with('{"key": "value"}')
```

**assert_called()** — объект был вызван.

**assert_called_once()** — объект был вызван хотя бы один раз.

**assert_called_with()** — объект был вызван с таким-то значением.

**assert_called_once_with()** — объект был вызван хотя бы один раз с таким-то значением.

Mock-объекты удобны еще тем, что позволяют заранее моделировать ответ на вызов того или иного метода, устанавливать значение переменной. Это означает, что в примере с базой данных в тестах, в методе **setUp()** можно создать **Mock**, эмулирующий подключение к базе данных, выполнение запросов к ней и ответов. Это в итоге позволит абстрагировать написание тестов от необходимости подключения к БД, а также от конкретных особенностей различных баз данных.

```python
>>> mock = Mock(name='Real Python Mock')
>>> mock
<Mock name='Real Python Mock' id='4434041432'>
>>> mock = Mock(return_value=True)
>>> mock()
True
```

В данных примерах идет конфигурирование ответа при вызове Mock-объекта.

```python
>>> mock = Mock(name='Real Python Mock')
>>> mock.name
<Mock name='Real Python Mock.name' id='4434041544'>
>>> mock = Mock()
>>> mock.name = 'Real Python Mock'
>>> mock.name
'Real Python Mock'
```

Тут Mock-объект **mock.name** заменяется на строку и теперь при вызове **mock.name** в ответе будет именно строка.

Рассмотрим пример применения Mock-объекта при написании тестов:

```python
import unittest
from unittest.mock import Mock
class SomeTextCorrector:
    def __init__(self, items, id=None):
        self.items = items
    def correct(self, text_object):
        temp_str = text_object.original_text
        for substring in self.items["trash_substrings"]:
            if substring in temp_str:
                temp_str = temp_str.replace(substring, "")
        text_object.original_text = temp_str.strip()
        return text_object
class TestSomeTextCorrector(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        items = {
        'trash_substrings': ["спам", "кредит"]
        }
        cls.filter = SomeTextCorrector(items)
    def test_1(self):
        text_object = Mock()
        text_object.original_text = "спам всегда приходит по возможности взять кредит"
        result = TestSomeTextCorrector.filter.correct(text_object)
        self.assertEqual('всегда приходит по возможности взять', result.original_text)
if __name__ == '__main__':
    unittest.main()
```

Тут создается класс **SomeTextCorrector**, который с помощью метода **correct()** удаляет лишние строки из **original_text** объекта **text_object**.

Так как во время написания теста мы не знаем о том, что из себя представляет класс, объектом которого является **text_object**, мы используем класс **Mock** для создания заглушки этого класса. Затем создаем переменную **original_text** и присваиваем ей строку со словами «спам» «кредит», чтобы метод **correct()** правильно отработал. Вызываем метод **correct()** и передаем Mock-объект и проверяем результат.



## Задание

В предыдущих модулях вами были написаны различных функции и классы. В этот раз мы предлагаем написать тесты для них. Во время работы постарайтесь ответить для себя на вопросы:

1. В каких случаях необходимо применить **Mock**?

2. На какие краевые условия необходимо написать тесты для ваших классов?

3. Как можно применить методы **setUp()** и **tearDown()**?



# Метаклассы

## Old style / new style classes

> Метапрограммирование — это разработка программ, которая в результате своей работы создаёт другие программы и может влиять на всё семейство созданных программ.

В Python мы имеем подвид метапрограммирования, основанный на классах и называемых метаклассами. Во время ежедневной разработки вы и так их используете, просто они скрыты под капотом Python. В 99% случаев метаклассы не нужны, но понимание их работы имеет смысл, поскольку оно ведет к лучшему пониманию возможностей Python в целом и позволяет более элегантно решить задачу, когда это потребуется.

> В Python, классы могут быть двух разновидностей: классы нового и старого стилей.

В *классах старого стиля* (old style classes), тип и класс — это несколько разные вещи. Объект класса старого стиля всегда реализует встроенный тип **instance**. Но в то же время **obj.__class__** возвращает конкретный класс, функция **type(obj)** возвращает **instance**.

Пример для Python2:

```python
>>> class Foo:
...    pass
...
>>> x = Foo()
>>> x.__class__
<class __main__.Foo at 0x000000000535CC48>
>>> type(x)
<type 'instance'>
```

В *классах нового стиля* (new style classes), понятия класс и тип унифицированы. Если **obj** — объект класса, то **type(obj)** - это **obj.__class__()**:

Пример для Python3:

```python
>>> class Foo:
...    pass
>>> obj = Foo()
>>> obj.__class__
<class '__main__.Foo'>
>>> type(obj)
<class '__main__.Foo'>
>>> obj.__class__ is type(obj)
True
```

В Python3 все классы являются классами нового стиля, поэтому правильно говорить о типе и классе объекта, как об одинаковых вещах.

В Python2 все классы по умолчанию являются классами старого стиля, с версии 2.2 появились классы нового стиля, но для их объявления нужно явно наследовать класс от **object**.

Пример для Python2:

```python
class Foo(object):
pass
```

Во многих проектах, которые мигрируют с Python2 на Python3, в порядке вещей встретить классы, унаследованные от **object**, просто нужно понимать, что в Python3 наличие явного наследования от **object** не является обязательным.

Так как в Python все является объектом, логично предположить, что классы тоже являются объектом. Проверим это:

```python
>>> class Foo:
...    pass
...
>>> x = Foo()
>>> type(x)
<class '__main__.Foo'>
>>> type(Foo)
<class 'type'>
```

Как видно, все классы являются объектами класса **type**.

Но в то же время класс **type** также является объектом класса **type**.

```python
>>> type(type)
<class 'type'>
```

**Type** — это метакласс, объектами которого являются любые классы в Python, но в тоже время класс **type** является экземпляром метакласса **type**, как показано на следующем рисунке:

![img](https://cs.sberbank-school.ru/image/1000/auto/upsize/14188792-60bc-11eb-aceb-0242ac180005)



## Динамическое создание классов

Встроенная функция **type()** при передаче одного параметра возвращает тип объекта. 

```python
>>> type(3)
<class 'int'>

>>> type(['foo', 'bar', 'baz'])
<class 'list'>

>>> t = (1, 2, 3, 4, 5)
>>> type(t)
<class 'tuple'>

>>> class Foo:
...    pass
...

>>> type(Foo())
<class '__main__.Foo'>
```

Но на самом деле при вызове **type()** происходит создание нового класса, который является объектом метакласса **type**.

Рассмотрим на примере, как можно динамически создать новый класс с помощью функции **type()**.

```python
>>> NewClass = type('NewClass', (), dict(attr=1))
>>> x = NewClass()
>>> x.attr
1
>>> x.__class__
<class '__main__.NewClass'>
>>> x.__class__.__bases__
(<class 'object'>,)
```

Здесь первый аргумент функции **type()** — имя класа, второй — кортеж базовых классов, третий — словарь аргументов.



## Собственный метакласс

Первое, с чего следует начать при создании *собственного метакласса*, это объявить новый класс, унаследовав его от **type**.

```python
class Meta(type):
    def __new__(cls, name, bases, dct):
        x = super().__new__(cls, name, bases, dct)
        x.attr = 100
        return x
```

В этом примере, помимо наследования, мы переопределяем метод **__new__()**. 

В строчке **super().__new__(cls, name, bases, dct)** создается объект **type** — это новый класс.

В строчке **x.attr = 100** новому классу присваивается уже встроенный атрибут **attr = 100**.

В строчке **return x** возвращается новый класс.

Теперь, чтобы новый пользовательский класс включил в себя особенности нового метакласса **Meta**, нужно сделать следующее:

```python
class Foo(metaclass=Meta):
    pass
f = Foo()
print(f.attr)
```

Вывод:

```python
100
```

Во время создания, используя ключевое слово **metaclass**, нужно указать, что класс **Foo** теперь использует не метакласс **type**, а метакласс **Meta**.

#### Когда следует создавать собственные метаклассы?

Учитывая богатый функционал Python с возможностью наследования (в том числе и множественного), использованием декораторов для обертки классов, остается все меньше места, чтобы однозначно ответить на вопрос, почему же следует создавать метакласс, а не базовый или абстрактный класс.

Однако, если перед вами стоит задача внести общую логику для работы с целым набором классов, которые могут быть не связаны логически между собой, то в этом случае применение метаклассов может быть оправдано. 

Например, это может быть проверка на стилистически правильное именование констант и атрибутов в классе, добавление уникальных атрибутов для каждого класса, которое можно применить при логировании или записи в БД.



# Сборщик мусора

## Как работает сборщик мусора

При разработке проекта в Python разработчик не заботится о таких вещах, как выделение и освобождение памяти, что свойственно для разработки на C++ и C. Как только созданные объекты больше не нужны, *сборщик мусора* автоматически освободит память из-под них.

CPython (стандартный интерпретатор Python) использует два механизма для сборки мусора — *подсчет ссылок на объекты* и *generational garbage collector* (модуль **gc** в стандартной библиотеке Python).

### Алгоритм подсчета ссылок

Как известно, в Python все переменные являются ссылками на объекты. Естественно, на один объект может ссылаться несколько переменных.

```python
typedef struct _object {
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt;
    PyTypeObject *ob_type;
} PyObject;
```

Так выглядит структура CPython, на основе которой реализованы другие, более сложные примитивы CPython. Здесь переменная **ob_refcnt** — переменная, которая увеличивается каждый раз, когда на данный объект создается ссылка.

Когда эта связь пропадает, естественно, счетчик ссылки объекта уменьшается.

Каждый раз, когда счетчик ссылок становится равным нулю, запускается механизм уничтожения объекта, при этом удаляются и ссылки, которые этот объект имел к другим объектам, таким образом, уничтожение одного объекта может повлечь волну удалений других объектов.

Основной проблемой, которой обладает алгоритм подсчета ссылок, является невозможность разрешения циклических зависимостей. Эту проблему призван решить generational garbage collector.

В Python с помощью функции **sys.getrefcount()**, всегда можно узнать количество ссылок на объект.

```python
import sys
test_list = [1,2,3]
print(sys.getrefcount(test_list))
test_list_2 = test_list
print(sys.getrefcount(test_list_2))
```

Вывод:

```python
2
3
```

В примере создается список и не него ссылается переменная **test_list**, количество ссылок равно 1. Когда применяется функция **sys.getrefcount()**, количество ссылок возрастает до 2. Затем мы создаем еще одну переменную **test_list_2** и присваиваем ей переменную **test_list**, счетчик ссылок равен 2, а вновь при применении **getrefcount()** становится равным 3.

Функция **sys.getrefcount()** обычно возвращает количество ссылок большее на единицу, чем ожидалось.

Это связано с созданием временной ссылки на аргумент, который передается в функцию.

### Generational garbage collector (GC)

*Циклическая ссылка* — это когда один или несколько объектов ссылаются друг на друга.

```python
a = []
a.append(a)
```

Здесь список ссылается сам на себя.

```python
a = {}
b = {}
a["b"] = b
b["a"] = a
```

Здесь словари ссылаются друг на друга.

Если вызвать метод **del()**, то произойдет удаление ссылок на объекты. Если бы не было GC, то объекты так бы и остались висеть в памяти, хотя и были бы недоступны для разработчика.

В отличие от подсчета ссылок, GC не срабатывает в реальном времени и запускается периодически. Для определения частоты запусков применяются встроенные эвристики. 

Generational означает «относящийся к определенному поколению» и, действительно, GC все объекты разделяет на три поколения. Изначально все объекты помещаются в первое поколение, живут там некоторое время и большинство из них очищается, остальная часть перемещается во второе поколение и потом в третье. Чем выше поколение, тем реже оно сканируется на мусор. 

Для выявления циклических ссылок GC итерирует каждый объект в поколении и временно удаляет все ссылки, на которые этот объект ссылается. После полного обхода, все обьекты, у которых счетчик ссылок меньше двух, считаются недоступными и удаляются.

GC как модуль несет для разработчика возможность управлять сборщиком мусора для циклических ссылок.

```python
import gc
gc.enable() - включение сборщика мусора
gc.disable() - выключение сборщика мусора
gc.collect(generation=2) - явно инициирует проход сборщика мусора до его автоматического запуска
```



### Полезная ссылка

Более подробно о возможностях модуля **gc** можно [прочитать тут](https://docs.python.org/3/library/gc.html).



## Менеджмент памяти

Python — динамический язык, во время работы которого создается множество объектов. Некоторые из них могут содержать другие объекты - списки, словари, кортежи.

Если новый создаваемый объект занимает в памяти больше, чем 512 байт, то Python отправляет его на стандартный С-аллокатор.

Для оптимизации выделения памяти под небольшие объекты размером менее 512 байт, Python заранее выделяет большие блоки памяти, которые разделены на три уровня — арены, пулы, блоки.

***Блок*** — это участок памяти определенного размера, каждый блок содержит только один Python-объект фиксированного размера, кратного 8. Размер блока от 8 до 512 байт.

***Пул*** — это коллекция блоков одинакового размера. Обычно размер пула — это 4 КБ. Если объект уничтожается, то занимаемая им память не отдается операционной системе, а сохраняется для будущих объектов такого же размера.

Пул и блоки не выделяют память напрямую, а используют память, выделенную аренами.

***Арена*** — участок памяти в 256 КБ, выделенный из кучи операционной системы, которая вмещает в себя 64 пула.

Схематично арена выглядит так:

| Arena     |               |               |
| --------- | ------------- | ------------- |
| Pool(4kB) | Pool(4kB)     | Pool(4kB)     |
| Pool(4kB) | Pool(4kB)     | Pool(4kB)     |
| Pool(4kB) | FreePool(4kB) | FreePool(4kB) |
| ...       | ...           | ...           |


В связи с таким устройством менеджера памяти в Python, освобождение ресурсов операционной системы происходит на практике редко. Это возможно, только если арена содержит в себе 64 пустых пула. При коротких операциях, когда нужно быстро произвести вычисления, это возможно. При долго живущих процессах можно наблюдать большое потребление памяти, которая, на самом деле, не используется эффективно.



# Потоки и процессы

## Основы процессов и потоков

Прежде чем переходить к описанию возможностей по использованию нескольких потоков или процессов в своей программе, предлагаем повторить базис, на котором будем основываться.

*Процесс* — это часть виртуальной памяти и ресурсов, которые операционная система выделяет для выполнения программы.

Каждый процесс выполняется в отдельном адресном пространстве и не может получить доступ к ресурсам другого процесса. 

*Поток* — это отдельная «нить» (поток) выполнения внутри процесса. 

У каждой программы есть как минимум один процесс, а у каждого процесса — минимум один поток, который называют *главным*. 

Разница между потоками и процессами состоит в том, что потоки используют память, выделенную под процесс, процессы в свою очередь обмениваются данными между собой только с помощью механизмов межпроцессного взаимодействия, а потоки обращаются к ресурсам друг друга напрямую. 

*Многопоточность* — это разбиение процесса программы на множество потоков, которые работают параллельно друг с другом. Например, одновременное получение нескольких html-страниц с разных сайтов.

*Многопроцессорность* — это разбиение программы на несколько независимых процессов. Например, один процесс в программе реализует основную бизнес-логику, другой процесс запускает веб-сервер, необходимый для мониторинга жизни приложения.



## GIL

К сожалению, в Python и его стандартном интерпретаторе CPython только кажется, что потоки выполняются параллельно, на самом деле они выполняются последовательно. Это связано с *GIL (Global Interpreter Lock)*, который ограничивает Python на один запущенный поток в единицу времени.

В предыдущем модуле, посвященном сборщику мусора, было описано, что в Python существует система подсчета ссылок на объекты. Проблема, которую решает GIL, связана с возможностью одновременного увеличения или уменьшения ссылок на объекты разными потоками. Может возникнуть ситуация, когда один поток уменьшит число ссылок на объект и Python удалит его, а другой поток будет использовать только что удаленный объект, что приведет к ошибке.

В теории такая проблема может быть решена добавлением блокировок к каждому объекту, но, к сожалению, это может привести к проблеме взаимоблокировок — это когда потоки будут находится в режиме ожидания ресурсов, который захватил другой поток, и так бесконечно.

> GIL — это блокировка самого интерпретатора Python. То есть, она является единственной блокировкой в системе и позволяет решить проблему взаимоблокировок, но в свою очередь делает все приложения однопоточными.

#### Так хорошо ли GIL или плохо?

Если разделить все программы на CPU-зависимые (обработка изображений, умножение матриц) и I/O-зависимые (связь по сети, обращение к БД), то можно понять, что использование потоков и GIL не несет ничего критического при I/O-операциях, т.к. время, затраченное Python на переключение потоков, будет компенсировано временем I/O-операций. При этом естественно, что, в не зависимости от количества ядер процессора, любая многопоточная программа на Python не сможет раскрыть потенциал и будет работать даже медленнее однопоточной за счет переключения GIL между потоками.

Рассмотрев GIL, следует обратиться к Python-модулю **threading**, который отвечает за создание и работу с потоками.

```python
import threading
import time
def thread_function(name):
    print(name, " - thread starting")
    time.sleep(2)
    print(name, " - after sleep")
if __name__ == "__main__":
    print("before create Thread")
    x = threading.Thread(target=thread_function, args=(1,))
    print("before running Thread")
    x.start()
    print("Wait thread finish")
    # x.join()
    print("all done")
```

Вывод:

```python
before create Thread
before running Thread
1 - thread starting
Wait thread finish
all done
1 - after sleep
```

В данном примере:

1. Мы импортируем модуль **threading.**
2. Создаем объект класса **Thread**, передавая ему на вход функцию, с которой он начнет работу, и аргументы для этой функции. 
3. Методом **start()** можно запустить поток, и, когда он завершит выполнение функции t**hread_function()**, он автоматически завершится.

Также во время создания объекта класса **Thread** можно передать параметр **daemon=True**, который позволит создать *daemon-поток*.

```python
x = threading.Thread(target=thread_function, args=(1,), daemon=True)
```

В теории *daemon-процесс* — это процесс, который работает в фоновом режиме.

В Python различают обычные потоки и daemons-потоки. Приложение для остановки будет ждать корректного завершения обычных потоков, daemons-потоки же будут просто убиты. Можно представить, что daemon-поток — это фоновый поток, о завершении которого можно не беспокоиться.

В предыдущем примере **x.join()** был закомментирован.

**x.join()** — это указание основному потоку дождаться завершения потока **x**. Это может быть полезно в случае, когда дочерние потоки делают какую-то работу, а основной поток впоследствии работает с данными, которые подготовили дочерние потоки.

Пример, который описан выше, позволяет создавать один поток, а для запуска нескольких можно комбинировать их, помещая в список:

```python
import threading
import time
def thread_function(name):
    print(name, " - thread start")
    time.sleep(2)
    print(name, "- thread job's done")
if __name__ == "__main__":
    threads = []
    for index in range(3):
        print("create thread - ", index)
        x = threading.Thread(target=thread_function, args=(index,))
        threads.append(x)
        x.start()

    for index, thread in enumerate(threads):
        print("before join - ", index)
        thread.join()
        print("after join - ", index)
```

Вывод:

```python
create thread - 0
0 - thread start
create thread - 1
1 - thread start
create thread - 2
2 - thread start
before join - 0
1 - thread job's done
2 - thread job's done
0 - thread job's done
after join - 0
before join - 1
after join - 1
before join - 2
after join - 2
```

Можно видеть, что, после старта потоков, главный поток зависает в ожидании потока под номером 0. Но потоки почти в одинаковое время завершают работу, поэтому остальные **join()** проходят быстро.

Помимо создания нескольких потоков и хранения их в списке, в Python есть возможность использовать **ThreadPoolExecutor**, который позволяет создать **N** потоков более просто.

```python
from concurrent.futures import ThreadPoolExecutor
import threading
import time
def thread_function():
    time.sleep(2)
    print("thread_function Executed {}".format(threading.current_thread()))
def main():
    executor = ThreadPoolExecutor(max_workers=3)
    task1 = executor.submit(thread_function)
    task2 = executor.submit(thread_function)
if __name__ == '__main__':
    main()
```

Вывод:

```python
thread_function Executed <Thread(ThreadPoolExecutor-0_0, started daemon 123145549160448)>
thread_function Executed <Thread(ThreadPoolExecutor-0_1, started daemon 123145554415616)>
```

В этом примере создается **ThreadPoolExecutor**, с количеством потоков равным **3**, и с помощью объекта **executor** передается функция, которую нужно выполнить. Как видно из вывода, разные потоки выполняют эту функцию.



## Примитивы синхронизации потоков

Одной из особенностей при написании многопоточных программ является состояние гонки. Это состояние возникает, когда два или более потоков обращаются к общим ресурсам. 

Например, мы имеем базу данных, в одной из ячеек которой лежит число, допустим, **0**. Запуская два потока одновременно через **ThreadPoolExecutor**, мы запускаем функцию, которая считывает число, увеличивает его на **1** и записывает в базу данных.

```python
class DataBase:
    def __init__(self):
        self.value = 0
    def update(self, name):
        print(name, " - start thread")
        local_copy = self.value
        local_copy += 1
        time.sleep(0.1)
        self.value = local_copy
        print(name, " - finish thread")
```

Мы ожидаем, что первый поток запишет **1**, а второй впоследствии увеличит **1** до **2**. Но т.к. обращение происходит практически одновременно (вспомним GIL), в результате так и останется **1**. Так как оба потока считают **0** в качестве исходных данных. 

Чтобы успешно разрешить состояние гонки, в Python добавлены примитивы синхронизации, которые многим могут быть знакомы из других языков программирования.

> Lock — это блокировка, которая может одновременно удерживаться только одним потоком.

Если другой поток хочет получить доступ к *lock*, который занял другой поток, то он будет вынужден ждать, пока занявший поток не отпустит блокировку.

```python
lock = threading.Lock()
lock.acquire() # Выполнит блокировку данного участка кода
# какой-то код
lock.release() # освобождение блокировки
```

Что удобно, можно использовать контекстный менеджер и не беспокоиться о необходимости выполнять явную блокировку / разблокировку.

```python
    with self._lock:
        local_copy = self.value
        local_copy += 1
        time.sleep(0.1)
        self.value = local_copy
```

*Семафор* чем-то похож на **Lock** с той лишь разницей, что в него встроен счетчик, который блокирует доступ в случае превышения числа потоков, которые удерживают семафор. 

```python
import threading
max_connections = 10
semaphore = threading.BoundedSemaphore(max_connections)
semaphore.acquire() # уменьшает счетчик (-1)
... доступ к общим ресурсам
semaphore.release() # увеличивает счетчик (+1)
```

С каждым **acquire()** счетчик уменьшается, **с release()** — увеличивается, но когда счетчик равен **0**, новый поток будет вынужден ждать, пока не освободится место для него.

Так же во время разработки программы с многопоточностью удобно использовать модуль **Queue**, который реализует механизм очередей с поддержкой **threadsafe**. Это означает, что, используя очередь, можно безопасно обмениваться информацией между потоками.

```python
import threading
import time
from queue import Queue
from threading import Thread
num_worker_threads=2
def do_work(item):
    time.sleep(1)
    print("my task is", item, "i am ", threading.current_thread())

def worker():
    while True:        
        item = q.get() # получаем задание из 
        print("get task - ", item)
        do_work(item) # выполняем работу
        q.task_done() # сообщаем о завершении работы
q = Queue()
for i in range(num_worker_threads): # Создаем и запускаем потоки
    t = Thread(target=worker)
    t.setDaemon(True)
    t.start()
for item in range(0, 5): # помещаем задания в очередь
    q.put(item)
q.join() # Ждем, пока не будут выполнены все задания
```

Вывод:

```python
get task - 0
get task - 1
my task is 0 i am <Thread(Thread-1, started daemon 123145343508480)>
get task - 2
my task is 1 i am <Thread(Thread-2, started daemon 123145348763648)>
get task - 3
my task is 2 i am <Thread(Thread-1, started daemon 123145343508480)>
get task - 4
my task is 3 i am <Thread(Thread-2, started daemon 123145348763648)>
my task is 4 i am <Thread(Thread-1, started daemon 123145343508480)>
```

В данном примере мы запускаем несколько потоков, создаем очередь и помещаем в нее задания. Потоки, используя безопасный метод **q.get()**, получают задания и выполняют их. 

На таком примере можно легко реализовать собственный скрипт для скачивания сайтов по доступным urls или приложение, которое после обсчета некоторых данных отдаст задачу на добавление результатов в базу данных.



## Модуль multiprocessing

Модуль **multiprocessing** несет в себе возможность создавать процессы таким же образом, как и потоки из модуля **threading**. Таким образом, можно обойти GIL и получить настоящую параллельную работу. 

Рассмотрим на примере, как создать новый процесс:

```python
import os
from multiprocessing import Process, current_process
def foo(number):
    proc_name = current_process().name
    print('{0} {1}'.format(
        number, proc_name))
if __name__ == '__main__':
    random_numbers = [5, 10, 15, 20, 25]
    process_list = []
    proc = Process(target=foo, args=(5,))
    for index, number in enumerate(random_numbers):
        proc = Process(target=foo, args=(number,))
        process_list.append(proc)
        proc.start()   
    proc = Process(target=foo, name='Test', args=(2,))
    proc.start()
    process_list.append(proc)
    for proc in process_list:
        proc.join()
```

Вывод:

```python
5 Process-2
10 Process-3
15 Process-4
20 Process-5
25 Process-6
2 Test
```

Тут мы создаем новый процесс, используя класс **Process**, стартуем его и в цикле **for** говорим главному процессу Python подождать, пока не завершатся все дочерние процессы, созданные ранее.

Класс **Process** в качестве аргументов принимает:

1. **Target** — функцию, которая будет выполняться при запуске процесса.
2. **Name** — имя процесса, доступного через функцию **current_process()**.
3. **args** — аргументы для функции **target().**

Также, как и с потоками, процессы поддерживают **Lock** для блокировки доступа к ресурсам.

```python
from multiprocessing import Process, Lock, current_process
def print_function(item, lock):
    lock.acquire()
    try:
       print(item, current_process())
    finally:
        lock.release()
if __name__ == '__main__':
    lock = Lock()
    items = ['test1', 'test2', "test3"]    
    for item in items:
        p = Process(target=print_function, args=(item, lock))
        p.start()
```

Вывод:

```python
test1 <Process(Process-1, started)>
test2 <Process(Process-2, started)>
test3 <Process(Process-3, started)>
```

По примеру можем видеть, что, благодаря **Lock**, процессы работают с функцией по очереди.

Аналогом **ThreadPoolExecutor** является класс **Pool**, который позволяет запустить несколько процессов одновременно.

```python
from multiprocessing import Pool
def calc(number):
    return number * 2
if __name__ == '__main__':
    numbers = [5, 10, 20]
    pool = Pool(processes=3)
    print(pool.map(calc, numbers))
```

Вывод:

```python
[10, 20, 40]
```

Мы создаем экземпляр класса **Pool**, указываем в **processes**, что хотим создать **3** процесса, а затем с помощью **pool.map()** передаем функцию для исполнения и список **numbers**, где впоследствии каждый из элементов списка будет подан на вход функции **doubler()**.

Для связи между процессами можно использовать уже знакомый класс **Queue**, который так же реализован в модуле **multiprocessing**

```python
from multiprocessing import Process, Queue
stop_number = -1 
def task_creator(data, q):
    for item in data:
        q.put(item)
def consmuer(q):
    while True:
        data = q.get()
        print('data: {}'.format(data))
        processed = data * 2
        print(processed)
        if data is stop_number:
            break
if __name__ == '__main__':
    q = Queue()
    data = [5, 10, 13, -1]   
    process_one = Process(target=task_creator, args=(data, q))
    process_two = Process(target=consmuer, args=(q,))
    process_one.start()
    process_two.start()
    q.close()
    q.join_thread()
    process_one.join()
    process_two.join()
```

Вывод:

```python
data: 5
10
data: 10
20
data: 13
26
data: -1
-2
```

Здесь мы создаем два процесса и очередь. Один процесс при старте кладет данные в очередь, а другой считывает ее и выводит на экран. 

Очереди удобны, когда нужно связать между собой несколько процессов, например, одни кладут в очередь, другие обрабатывают.

Но в модуле **multiprocessing** так же есть класс **Pipe**, который позволяет связать между собой только два процесса.

```python
import multiprocessing  
def sender(conn, msgs):
    for msg in msgs:
        conn.send(msg)
        print("Sent the message: {}".format(msg))
    conn.close()

def receiver(conn):
    while 1:
        msg = conn.recv()
        if msg == "END":
            break
        print("Received the message: {}".format(msg))

if __name__ == "__main__":
    msgs = ["START", "END"]
    parent_conn, child_conn = multiprocessing.Pipe()
    p1 = multiprocessing.Process(target=sender, args=(parent_conn,msgs))
    p2 = multiprocessing.Process(target=receiver, args=(child_conn,))  
    p1.start()
    p2.start() 
    p1.join()
    p2.join()
```

Вывод:

```python
Sent the message: START
Sent the message: END
Received the message: START
Received the message: END
```

В этом примере мы создаем два процесса, связываем их с помощью **Pipe** и организуем простую передачу текстовых сообщений от одного к другому.

Хочется отметить, что **Pipe** возвращает два объекта — **parent_conn** и **child_conn**.

**parent_conn** — объект, который отправляет данные через **Pipe**.

**child_conn** — объект, которые принимает данные из **Pipe**.

**Pipe** полезно использовать, когда один процесс работает в фоне, например, мониторит доступность сети, а другой процесс хочет сходить по какому-нибудь адресу и спрашивает о доступности сети у другого процесса, а потом принимает на основе этого решение.



## Задания

### Задание 1

Для тренировки навыка многопоточного программирования предлагаем решить классическую задачу об обедающих философах.

Пять безмолвных философов сидят вокруг круглого стола, перед каждым философом стоит тарелка спагетти. Вилки лежат на столе между каждой парой ближайших философов.

Каждый философ может либо есть, либо размышлять. Прием пищи не ограничен количеством оставшихся спагетти — подразумевается бесконечный запас. Тем не менее, философ может есть только тогда, когда держит две вилки — взятую справа и слева (альтернативная формулировка проблемы подразумевает миски с рисом и палочки для еды вместо тарелок со спагетти и вилок).

Каждый философ может взять ближайшую вилку (если она доступна) или положить — если он уже держит её. Взятие каждой вилки и возвращение ее на стол являются раздельными действиями, которые должны выполняться одно за другим.

Вопрос задачи заключается в том, чтобы разработать модель поведения (параллельный алгоритм), при котором ни один из философов не будет голодать, то есть будет вечно чередовать приём пищи и размышления.

### Задание 2

Реализовать скачивание html-страниц по списку с сохранением на жесткий диск с использованием многопоточного или многопроцессорного подхода.



# Шаблоны (паттерны) проектирования

## Поведенческие шаблоны

> **Шаблоны проектирования** — это типовое решение проблемы, которая может возникнуть в результате проектирования архитектуры проекта.

Особенностью шаблонов является общая концепция работы, которую нужно индивидуально применить к конкретному случаю.

Написание вашего приложения с помощью *шаблонов проектирования* позволит повысить качество кода, его читабельность, расширяемость и переносимость. Проект, больше 70% которого можно разложить на шаблоны, как правило, имеет высокие показатели качества.

Различают несколько видов шаблонов:

***Поведенческие шаблоны*** — это шаблоны для эффективной коммуникации между объектами. К ним относят шаблоны: Стратегия (Strategy), Наблюдатель (Observer), Команда (Command), Состояние (State).

***Порождающие шаблоны** —* это шаблоны для гибкого создания объектов без лишних зависимостей. К ним относят шаблоны: Одиночка (Singletone), Абстрактная фабрика (Abstract Factory), Строитель (Builder), Фабрика (Factory).

***Структурные шаблоны** —* это шаблоны для построения различных связей между объектами. К ним относят шаблоны: Декоратор (Decorator), Фасад (Facade), Заместитель (Proxy), Адаптер (Adapter), Компоновщик (Composite).

> **Стратегия (Strategy)** — это шаблон, позволяющий вынести схожие алгоритмы во взаимозаменяемые собственные классы, которые меняют поведение системы во время исполнения программы.

Пример: при разработке системы кратчайшего пути для курьера можно сделать семейство алгоритмов, которое вычисляет кратчайший путь в зависимости от транспортных средств курьера: пешком, на авто, на велосипеде.

```python
from abc import ABC, abstractmethod
class Strategy(ABC):
    """
     Абстрактный класс для стратегии
    """
    @abstractmethod
    def calc_effictive_path(self, data):
        pass

class AutoStrategy(Strategy):
    """
     Стратегия для курьера на авто
    """
    def calc_effictive_path(self, data):
        # calc path
        return data

class BikeStrategy(Strategy):
    """
     Стратегия для курьера на велосипеде
    """
    def calc_effictive_path(self, data):
        # calc path
        return data

class Courier():
    def __init__(self, strategy: Strategy) -> None:
       """
        Принимает стратегию в качестве параметра
        """
        self._strategy = strategy
    @property
    def strategy(self) -> Strategy:
        """
            Доступ из кода
        """
        return self._strategy
    @strategy.setter
    def strategy(self, strategy: Strategy) -> None:
        """
            Установка новой стратегии
        """
        self._strategy = strategy

    def get_effective_path(self, data) -> None:
        """
            Расчитать эффективный путь для курьера
        """
        return self._strategy.calc_effictive_path(data)
```

> Наблюдатель (Observer) — это шаблон, позволяющий одним объектам следить и реагировать на события других объектов.

Пример: при выборе товара из интернет-магазина можно увидеть, что если товара нет на текущий момент в наличие, то можно подписаться на уведомление о том, что когда он появится, будет выслано письмо на e-mail. 

```python
from abc import ABC, abstractmethod
class ShopList():
    """
        Класс, реализующий список покупок
    """
    def __init__(self):
        self._observers = [] # список подписчиков
    def attach(self, observer):
        self._observers.append(observer)

    def detach(self, observer):
        self._observers.remove(observer)
    """
        Оповещение подписчиков об изменениях
    """
    def notify(self) -> None:
        for observer in self._observers:
            observer.update(self)

    def business_logic(self) -> None:
        """
            Какая-то бизнес-логика
        """
        self.notify()

class Observer(ABC):
    """
        Абстрактный класс наблюдателя
    """
@abstractmethod
    def update(self, shop_list_object) -> None:
        pass

class EmailObserver(Observer):
    def update(self, shop_list_object) -> None:
        pass

class SmsObserver(Observer):
    def update(self, shop_list_object) -> None:
        pass
```

> Команда (Command) — это шаблон, который преобразует запросы в объекты.

Пример: В консоли пользователь вызывает программу и передает ей на вход команду; из текстового вида она преобразуется в объект, выполнение ее способствует выполнению кода, который реализует необходимую бизнес-логику.

```python
from __future__ import annotations
from abc import ABC, abstractmethod

class Command(ABC):
    """
    Абстрактный класс Команды
    """
    @abstractmethod
    def execute(self):
        pass
class PrintCommand(Command):
    def execute(self):
        print("wohoo")

class CreateFileCommand(Command):
    def __init__(self, file_name):
        self._file_name = file_name

    def execute(self) -> None:
        f = open(self._file_name, "w+")
        f.close()

class CommandManager:
    """
    Инициализация команд.
    """
    def start_command(self, command: Command):
        self._start_command = command

    def stop_command(self, command: Command):
        self._stop_command = command

    def do_something(self) -> None:
        """
            Выполнение полезных действий с командами
        """
        pass
```

> Состояние (State) — это шаблон, позволяющий менять поведение объектов в зависимости от своего состояния.

Поведения, которые зависят от состояния, выносятся в отдельный класс; первоначальный класс хранит ссылку на объекты классов-поведений.

Пример: при разработке приложения для телефона, в случае отсутствия интернета, приложение посылает код для смены пароля от учетной записи через sms; если интернет подключен, то отправляет код через push-уведомление.

```python
from __future__ import annotations
from abc import ABC, abstractmethod

class ContextHandler(ABC):
    """
        Класс реализует бизнес-логику для приложения и хранит ссылки на состояния
    """

    def __init__(self, state):
        self._state = state

    def set_state(self, state: State):
        self._state = state
        self._state.context = self

    def send_request(self):
        self._state.handle()

class State(ABC):
    """
    Базовый класс Состояния
    """
    @property
    def context(self):
        return self._context

    @context.setter
    def context(self, context):
        self._context = context

    @abstractmethod
    def handle(self) -> None:
        pass

class SmsState(State):

    def send_sms(self, text):
        pass

    def handle(self) -> None:
        self.send_sms("test")

class PushState(State):

    def send_push(self, text):
        pass

    def handle(self) -> None:
        self.send_push("test")
```



## Порождающие шаблоны

> Одиночка (Singleton) — это шаблон, гарантирующий единственный объект класса и предоставляющий к нему глобальную точку доступа.

Один из самых известных паттернов, который необходимо применять с осторожностью, т.к. множество подключенных одиночек в проекте вызывают сильную связанность в коде, осложняют написание unit-тестов, будущий рефакторинг.

Пример: единственное подключение к базе данных в проекте при использовании многопоточности.

```python
from __future__ import annotations
from typing import Optional

class SingletonMeta(type):
    _instance = None
    def __call__(self):
        if self._instance is None:
            self._instance = super().__call__()
        return self._instance

class Singleton(metaclass=SingletonMeta):
    def some_logic(self):
        pass
```

> *Абстрактная фабрика (Abstract Factory)* — это шаблон, позволяющий создавать семейство связанных объектов, отвязавшись от классов конкретных объектов.

Пример: при проектировании интернет-магазина существуют категории, а в них уже конкретные варианты. В этом случае абстрактная фабрика позволяет описать создание категорий, а объекты категорий, в свою очередь, будут создавать конкретные товары.

```python
from __future__ import annotations
from abc import ABC, abstractmethod

class AbstractFactory(ABC):
    """
    Интерфейс Абстрактной Фабрики объявляет набор методов,
    которые возвращают различные абстрактные продукты
    """
    @abstractmethod
    def create_product(self):
        pass
    @abstractmethod
    def create_provider(self):
        pass

class TeaFactory(AbstractFactory):
    """
    Конкретная Фабрика, которая создает объекты чая
    """
    def create_product(self):
        return TeaProduct()
    def create_provider(self):
        return TeaProvider()

class CoffeeFactory(AbstractFactory):
    """
    Конкретная Фабрика, которая создает объекты кофе
    """
    def create_product(self):
        return CoffeeProduct()
    def create_provider(self):
        return TeaProvider()

class AbstractProduct(ABC):
    """
    Каждый отдельный продукт интернет магазина
    """
    @abstractmethod
    def some_function(self):
        pass

class TeaProduct(AbstractProduct):
    def some_function(self):
        return "I am tea"

class CoffeeProduct(AbstractProduct):
    def some_function(self):
        return "I am coffee"

class AbstractProvider(ABC):
    """
    Каждый отдельный продукт интернет-магазина
    """
    @abstractmethod
    def country_list(self):
        pass

class CoffeeProvider(AbstractProvider):
    def country_list(self):
        return ["Brazil","Kenia"]

    def some_business_logic():
        product = factory.create_product()
        provider = factory.create_provider()
        print(product.some_function())
        print(provider.country_list())

if __name__ == "__main__":
    some_business_logic(TeaFactory())
    some_business_logic(CoffeeFactory())
```

> Строитель (Builder) — шаблон, который позволяет создавать сложные объекты пошагово.

Пример: при разработке ПО для строительной компании может понадобиться создать прототип дома. Нужно выбрать материал корпуса, фундаменты, цветы стен и т.д. Получим объект типа дом, который состоит из набора более небольших объектов. Чтобы более гибко контролировать процесс создания объекта дома, можно выделить его в отдельный класс **HouseBuilder**.

```python
from abc import ABC, abstractmethod, abstractproperty

class AbstractBuilder(ABC):
    """
        Абстрактный класс строителя
    """
    @abstractproperty
    def product(self):
        pass
    @abstractmethod
    def build_part_1(self):
        pass
    @abstractmethod
    def build_part_2(self):
        pass
    @abstractmethod
    def build_part_3(self);
        pass

class HouseeBuilder(AbstractBuilder):
    def __init__(self):
        self.reset()
    def reset(self):
        self._house = House()
    @property
    def product(self):
        # получить экземпляр объекта
        house = self._house
        self.reset()
        return house
    def build_part_1(self):
        self._house.add("Walls")
    def build_part_2(self):
        self._house.add("Roof")
    def build_part_3(self) :
        self._house.add("Flat")

class House():
    def __init__(self):
        self.parts = []
    def add(self, part):
        self.parts.append(part)
    def list_parts(self) :
        print(self.parts)

class Director:
    """
        Опциональный класс, который управляет этапами строительства. 
        Обычно данный функционал достаточно выполнить в других
        классах / функциях, когда нужно создать объект.
        Применяется, если есть несколько строителей, которые создают
        разные сложные объекты, объединенные общей логикой.
    """
    def __init__(self):
        self._builder = None
    @property
    def builder(self):
        return self._builder
    @builder.setter
    def builder(self, builder):
        self._builder = builder
    def build_product(self):
        self.builder.build_part_1()
        self.builder.build_part_2()
        self.builder.build_part_3()
```

> Фабрика (Factory) — это шаблон, который позволяет создавать объекты класса, не раскрывая логики создания объектов.

```python
from abc import ABCMeta, abstractmethod

class Worker(metaclass=ABCMeta):
    @abstractmethod
    def who_i_am(self):
        pass

class SimpleWorker(Worker):
    def who_i_am(self):
        print('I am simple worker')

class Developer(Worker):
    def who_i_am(self):
        print("Developer is here")

class DevOpsMan(Worker):
    def who_i_am(self):
        print("DevOpsMan is here")

class WorkersFactory:
    registered_workers = {
        None: SimpleWorker,
        "developer": Developer,
        "dev_ops": DevOpsMan
    }
    @classmethod
    def create_worker(cls, worker_type=None):
         worker_cls = cls.registered_workers[worker_type]
         return worker_cls()

if __name__ == "__main__":
    w1 = WorkersFactory.create_worker()
    w1.who_i_am()
    w2 = WorkersFactory.create_worker("dev_ops")
    w2.who_i_am()
```



## Структурные шаблоны

> Декоратор (Decorator) — это шаблон, который позволяет добавлять объектам новую функциональность, как бы оборачивая их.

К счастью разработчиков на Python, данный шаблон встроен по умолчанию. 

Более подробно о работе с декораторами можно посмотреть в модуле «Функции». Тут же еще раз приведем пример работы с декораторами в Python.

```python
def func_time_decorator(func):
    import time
    def wrapper(*args, **kwargs):
        start = time.time()
        return_value = func(*args, **kwargs)
        end = time.time()
        print('[*] Время выполнения: {} секунд.'.format(end-start))
        return return_value
    return wrapper
```

> Фасад (Facade) — это шаблон, который предоставляет интерфейс к сложной системе классов, сторонних библиотек и фреймворков.

Пример: подключение нового функционала библиотеки Prometeus (для мониторинга), Jaeger (для трассировки) удобно делать с помощью классов, которые изолируют вызов и работу с этой библиотекой, отделяя ее от классов разрабатываемой системы.

```python
class FileAdapterFacade:
    """
        Фасад для доступа к файлам, который скрывает
        конкретную систему, где лежат файлы
    """
    def __init__(self, subsystem) -> None:
        self._file_system = subsystem
    def get_file(self, file_name):
        return self._file_system.get(file_name)

class LocalStorager:
    """
       Доступ к файлам на диске
    """
    def get_file(self, file_name):
        pass

class CephStorager:
    """
        Доступ к файлам, которые лежат удаленно в ceph bucket
        Данный класс вдобавок может реализовывать
        работы с библиотекой, подключения к ceph
    """ 
    def get_file(self, file_name):
        connector = self.connect()
        connector.set_s3_mode()
        connector.turn_off_ssl()
        connector.establish()
        file = connector.get_file(file_name)
        return file
```

> Адаптер (Adapter) — это шаблон, который позволяет объектам с разными интерфейсами работать вместе.

Пример: часто при разработке нескольких систем приходится разрабатывать систему-адаптер, которая через нее связывает несколько систем в единую. Внутри одного проекта это может быть класс, который готовит данные, а отдельные классы адаптируют их для отправки по rest или по kafka.

```python
# coding=utf-8
import requests

CORRELATION_ID = "correlationId" 

class HttpRequest:
    def __init__(self, url):
        self.url = url

    def request(self, obj):
        try:
            if CORRELATION_ID not in obj.headers.keys():
                raise AttributeError
            else:
                response = requests.get(
                    self.url,
                    params=obj.params,
                    headers=obj.headers,
                )
                print(response)
        except AttributeError:
            print("not correlationId in headers")

class OldClass:
    def __init__(self, headers, params):
        self.headers = headers
        self.params = params

class OldClassHttpRequestAdapter:
    def __init__(self, obj):
        self.obj = obj
    @property
    def headers(self):
        if CORRELATION_ID not in self.obj.headers.keys():
            self.obj.headers[CORRELATION_ID] = "1232-1112-3333"
        return self.obj.headers
    @property
    def params(self):
        return self.obj.params

http_request = HttpRequest("https://github.com")
old_class_obj = OldClass({"test":"111"}, {"params1":"value1"})
adapter_obj = OldClassHttpRequestAdapter(old_class_obj)
http_request.request(old_class_obj) 
http_request.request(adapter_obj)
```

Вывод:

```python
not correlationId in headers
<Response [200]>
```

> Компоновщик (Composite) — это шаблон, который позволяет сгруппировать множество объектов в дерево, а затем работать с ней, как с единым объектом.

Пример: при разработке программы под Windows / Mac с GUI, графический интерфейс можно представить в виде дерева, который с помощью компоновщика можно собрать в единое целое.

```python
from abc import ABC, abstractmethod

class GUIAbstractComponent(ABC):
    """
    Базовый класс абстрактный компонент GUI интерфейса 
    """
    @property
    def parent(self):
        return self._parent
    @parent.setter
    def parent(self, parent):
        self._parent = parent
    def add(self, component):
        pass
    def remove(self, component):
        pass
    @abstractmethod
    def action(self):
        pass

class Button(GUIAbstractComponent):
    """
        Не имеет вложенных компонентов, выполняет действия.
    """
    def action(self):
        return "Button"

class EditBox(GUIAbstractComponent):
    def action(self):
        return "Leaf"

class Window(GUIAbstractComponent):
    """
        Контейнер, который содержить в себе более простые объекты
    """
    def __init__(self):
        self._children = []
    def add(self, component):
        self._children.append(component)
        component.parent = self
    def remove(self, component):
        self._children.remove(component)
        component.parent = None
    def is_composite(self):
        return True
    def action(self):
        """
            Контейнер проходится по своим детям и вызывает у них
            действия, суммирует и отдает результат.
            Таким образом, можно организовать перерисовку
            всех компонентов в GUI.
        """
        results = []
        for child in self._children:
            results.append(child.action())
        return f"Branch({'+'.join(results)})"

if __name__ == "__main__":
    window = Window()
    window.add(Button())
    branch1.add(EditBox())
```

> Заместитель (Proxy) — это шаблон, который позволяет вместо реальных объектов передать «заместителей», которые позволяют перехватить обращение и выполнить действие до и после вызова.

Пример: вы используете библиотеку, которая реализовала доступ какому-нибудь ресурсу вашей сети, но в ней нет проверки на доступность этого ресурса. Вместо переписывания своего кода можно заменить объект класса из библиотеки собственным классом-заместителем, который реализует тот же самый метод, но перед этим собственными силами проверяет доступность ресурса в сети.

```python
class LocalWeb():
    def request(self):
        print("request to localweb")

class Proxy(LocalWeb):
    """
        Наследник от класса из библиотеки
    """
    def __init__(self, local_web):
        self._local_web = local_web
    def request(self):
        if self.check_access():
            self._local_web.request()
    def check_access(self) -> bool:
        return True
```

